---
title: "13주차 게시판 만들기 2단계"
excerpt: "2022-01-17 ~ 2022-01-21"

toc: true
toc_sticky: true
categories:
  - Study
---
<br>
# 게시판 작성일 포맷
---
게시글 작성일을 DB에 SYSDATE로 INSERT<br>
=> `Sun Jan 16 17:14:12 KST 2022` 포맷으로 출력됨<br>
<br>
JSP taglib를 사용하여 원하는 포맷으로 출력 가능<br>
<br>

```jsp
<%-- formatting library --%>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>

<%-- 중간 생략 --%>
<body>
<td><fmt:formatDate value="${data.boardVO.board_writedate }" pattern="yy.MM.dd" /></td>
<td><fmt:formatDate value="${data.boardVO.board_writedate }" pattern="yy-MM-dd" /></td>
<td><fmt:formatDate value="${data.boardVO.board_writedate }" pattern="yy년MM월dd일" /></td>
</body>
```

<br>
<br><br>

# 취미(Check Box)
---
회원가입 페이지에 취미 체크박스 추가<br>
radio 버튼과는 달리 check box는 추가/수정되는 일이 있음(가변적)<br>


<br><br>

## DB

취미 목록을 카테고리화하여 DB에 테이블로 저장(FP_Hobby_Category)<br>
멤버의 취미를 저장하는 DB 추가 생성(FP_MemberHobby)<br>
<br>
<br>
**ERD**

<center><img src="https://user-images.githubusercontent.com/57750308/150630229-332bced4-074c-4506-9b60-7220f6d3bca1.png"></center>

<br>

**다중 속성**<br>
- 하나의 회원은 여러 속성(취미)를 갖는다.
- ex) 쇼핑몰/배달어플 배송지 목록
- 다중 속성 처리
  * 별도의 다중 속성 저장용 테이블을 생성
  * 두 개의 테이블(Member, HobbyCategory)과 각각 1 : N 의 관계를 맺음
  * 한 명이 취미를 선택하여 회원가입하면 두 개의 테이블(Member, MemberHobby)에 INSERT 됨
<br>
<br>

`cf) 단일 속성 : 하나의 회원은 하나의 속성(ID, PW, ...)을 갖는다`<br>
`=> 해당 테이블에 속성 컬럼을 추가하여 값 저장`<br>
<br>

```sql
--취미 카테고리 Table
DROP TABLE FP_Hobby_Category;
CREATE TABLE FP_Hobby_Category(
	hobby_category_no NUMBER,
	hobby_category_name VARCHAR2(100)
);

DROP SEQUENCE FP_Hobby_Category_seq;
CREATE SEQUENCE FP_Hobby_Category_seq;

--INSERT로 취미 목록 정의(나중에 추가/수정/삭제 가능)
INSERT INTO FP_Hobby_Category VALUES(FP_Hobby_Category_seq.nextval, '야구');
INSERT INTO FP_Hobby_Category VALUES(FP_Hobby_Category_seq.nextval, '축구');
INSERT INTO FP_Hobby_Category VALUES(FP_Hobby_Category_seq.nextval, '농구');
INSERT INTO FP_Hobby_Category VALUES(FP_Hobby_Category_seq.nextval, '당구');
INSERT INTO FP_Hobby_Category VALUES(FP_Hobby_Category_seq.nextval, '테니스');

--사용할 쿼리
SELECT * FROM FP_Hobby_Category ORDER BY hobby_category_no ASC;

--멤버의 취미 Table
DROP TABLE FP_MemberHobby;
CREATE TABLE FP_MemberHobby (
	memberhobby_no NUMBER,
	member_no NUMBER,
	hobby_category_no NUMBER
);

DROP SEQUENCE FP_MemberHobby_seq;
CREATE SEQUENCE FP_MemberHobby_seq;

SELECT * FROM FP_MemberHobby;
```

<br>
<br>

## VO
FP_Hobby_Category, FP_MemberHobby의 속성과 동일한 필드명을 가진 VO 생성<br>
<br>

```java
// HobbyCategoryVO
package com.팀명.프로젝트명.vo;

public class HobbyCategoryVO {
	
	private int hobby_category_no;
	private String hobby_category_name;
	
	public HobbyCategoryVO() {
		super();
	}

	public HobbyCategoryVO(int hobby_category_no, String hobby_category_name) {
		super();
		this.hobby_category_no = hobby_category_no;
		this.hobby_category_name = hobby_category_name;
	}

	public int getHobby_category_no() {
		return hobby_category_no;
	}

	public void setHobby_category_no(int hobby_category_no) {
		this.hobby_category_no = hobby_category_no;
	}

	public String getHobby_category_name() {
		return hobby_category_name;
	}

	public void setHobby_category_name(String hobby_category_name) {
		this.hobby_category_name = hobby_category_name;
	}
}
```

<br>

```java
// MemberHobbyVO
package com.팀명.프로젝트명.vo;

public class MemberHobbyVO {
	// 필드
	private int memberhobby_no;
	private int member_no;
	private int hobby_category_no;
	// 생성자, getter/setter 작성
}
```

<br><br>

## Mapper
취미 관련하여 큰 기능이 없으므로 MemberSQLMapper에 작성<br><br>

현재 `member_no`는 멤버 테이블에 `FP_MEMBER_seq.nextval`로 INSERT 되고 있음<br>
<br>
=> 회원가입시 FP_Member, FP_MemberHobby 두 테이블에 `member_no`가 INSERT 돼야 함<br>
=> dual 테이블을 이용하여 먼저 `FP_Member_seq.nextval`을 받아온 뒤 두 테이블에 INSERT
<br><br>

```java
// MemberSQLMapper interface

// 취미 카테고리 관련
public int createMemberPK();
public ArrayList<HobbyCategoryVO> getHobbyCategoryList();
public void insertMemberHobby(MemberHobbyVO vo);
```

<br>

```xml
<!-- MemberSQLMapper.xml -->

<!-- member_no 추출 -->
<select id="createMemberPK" resultType="int">
	SELECT FP_Member_seq.nextval FROM dual
</select>

<!-- FP_Member_seq.nextval에서 member_no로 수정 -->
<insert id="joinMember">
	INSERT INTO FP_Member VALUES
	(#{member_no},		
	#{member_id},
	#{member_pw},
	#{member_nick},
	#{member_gender},
	#{member_birth},
	#{member_phone},
	#{member_email},
	SYSDATE)
</insert>

<!-- 취미 카테고리 관련 -->
<select id="getHobbyCategoryList" resultType="com.팀명.프로젝트명.vo.HobbyCategoryVO">
	SELECT *
	FROM FP_Hobby_Category
	ORDER BY hobby_category_no ASC
</select>

<!-- 회원 취미 -->
<insert id="insertMemberHobby">
	INSERT INTO FP_MemberHobby VALUES(
	FP_MemberHobby_seq.nextval,
	#{member_no},
	#{hobby_category_no}
	)
</insert>
```

<br>
<br>

## Service

```java
// MemberService

public void joinMember(MemberVO vo, int[] hobby_category_no) {
	// 파라미터 데이터를 가지고 코어로직(비즈니스 로직) 수행

	// member_no(PK) 먼저 생성
	int memberNo = memberSQLMapper.createMemberPK();
		
	// DB insert
	vo.setMember_no(memberNo);
	memberSQLMapper.joinMember(vo);
		
	if(hobby_category_no != null) {
			
		for(int hcNo : hobby_category_no) {
				
			MemberHobbyVO hVO = new MemberHobbyVO();

			// 회원 번호(dual에서 seq 조회로 받아온 값)
			hVO.setMember_no(memberNo);

			// 취미 카테고리 번호(회원 가입시 선택된 값)
			hVO.setHobby_category_no(hcNo);

			memberSQLMapper.insertMemberHobby(hVO);				
		}
	}
}
```

<br><br>

## Controller

```java
// MemberController

@RequestMapping("joinMemberPage")
public String joinMemberPage(Model model) {
	System.out.println("시스템 로그] 회원가입 페이지 실행");
		
	ArrayList<HobbyCategoryVO> list = memberService.getHobbyCategoryList();
		
	// model에 넣어 회원가입 jsp에서 취미 목록 출력 가능
	model.addAttribute("hobbyCategoryList", list);
		
	return "member/joinMemberPage";
}

@RequestMapping("joinMemberProcess")
// 회원가입 화면에서 선택한 취미들이 배열로 들어옴(int[] hobby_category_no)
public String joinMemberProcess(MemberVO param, int[] hobby_category_no) {
	System.out.println("시스템 로그] 회원가입 프로세스 실행");
	memberService.joinMember(param, hobby_category_no);
		
	return "member/joinMemberComplete";
}
```

<br>
<br>

## JSP

```jsp
<%-- joinMemberPage.jsp --%>
취미 :
<c:forEach items="${hobbyCategoryList }" var="hobbyCategory">
	<input type="checkbox" name="hobby_category_no" value="${hobbyCategory.hobby_category_no }">
	${hobbyCategory.hobby_category_name }
</c:forEach>

```

`=> 1, 3, 5번째 체크박스 선택했다면 hobby_category_no=1&hobby_category_no=3&hobby_category_no=5로 넘어옴`<br>
`(get 방식으로 확인 가능)`


<br>
<br><br>


# HTML escape
---
엔터 및 특문은 DB에서는 인식 하지만 HTML에서 인식 못 함<br>
=> 태그와 동일한 문자를 입력했을 경우 출력하면 문자열이 아닌 HTML 코드가 적용돼서 출력됨
<br><br>

특수문자를 문자 그자체로 인식하는 외부 lib 사용<br>
`엔터와 띄어쓰기는 lib에서 바꿔 주지 않아 String.replaceAll()을 사용하여 <br>과 &nbsp;로 치환`
<br>
<br>

## pom.xml

```xml
<!--  html escape 라이브러리 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-text</artifactId>
    <version>1.9</version>
</dependency>
```

<br><br>

## Service
글 수정할 때도 `getBoard()`에서 가져옴<br>
=> `replaceAll()`한 엔터와 띄어쓰기가 `<br>, &nbsp;`로 보임<br>
=> `isEscape` 파라미터를 추가하여 `true`일 경우(글 읽기)에만 escape 적용<br>
<br>

```java
// BoardService

public HashMap<String, Object> getBoard(int board_no, boolean isEscape) {
    HashMap<String, Object> map = new HashMap<>();
    
    BoardVO boardVO = boardSQLMapper.getBoardByNo(board_no);
    
    // HTML escape
    if(isEscape) {
        String content = boardVO.getBoard_content();
        
        // StringEscapeUtils가 두 종류 있음
        // org.apache.commons.text.StringEscapeUtils 사용
        content = StringEscapeUtils.escapeHtml4(content);
        
        // 엔터를 <br>로 치환(StringEscapeUtils는 엔터를 <br>로 안 바꿔줌)
        // HTML은 띄어쓰기 한 번만 인식 => 띄어쓰기를 띄어쓰기 특문으로 직접 치환
        // 직접 코드 상에서 수정해야함
        content = content.replaceAll("\n", "<br>");
        content = content.replaceAll(" ", "&nbsp;");
        boardVO.setBoard_content(content);
        
        // 제목에도 escape 적용
        boardVO.setBoard_title(
                StringEscapeUtils.escapeHtml4(boardVO.getBoard_title())
                .replaceAll("\n", "<br>").replaceAll(" ", "&nbsp;"));
    }
            
    int memberNo = boardVO.getMember_no();	
    MemberVO memberVO = memberSQLMapper.getMemberByNo(memberNo);
    
    map.put("memberVO", memberVO);
    map.put("boardVO", boardVO);
    
    return map;
}

public ArrayList<HashMap<String, Object>> getBoardList() {
    ArrayList<HashMap<String, Object>> dataList = new ArrayList<>();
    
    ArrayList<BoardVO> boardVOList = boardSQLMapper.getBoardList();
    
    for(BoardVO boardVO : boardVOList) {
        int memberNo = boardVO.getMember_no();	// 작성자 번호			
        
        // 제목에 escape 적용
        boardVO.setBoard_title(
                StringEscapeUtils.escapeHtml4(boardVO.getBoard_title())
                .replaceAll("\n", "<br>").replaceAll(" ", "&nbsp;"));
        
        // SELECT * FROM FP_Member WHERE member_no = #{no}
        MemberVO memberVO = memberSQLMapper.getMemberByNo(memberNo);
        
        HashMap<String, Object> map = new HashMap<>();
        map.put("memberVO", memberVO);
        map.put("boardVO", boardVO);
        
        dataList.add(map);
    }
    return dataList;
}
```

<br><br>

## Controller

```java
// BoardController

@RequestMapping("readContentPage")
public String readContentPage(int board_no, Model model) {
    boardService.increaseReadCount(board_no);
    
    // 글 읽기 => escape 필요(true)
    HashMap<String, Object> map = boardService.getBoard(board_no, true);
    
    model.addAttribute("data", map);
    
    return "board/readContentPage";
}
    
@RequestMapping("updateContentPage")
public String updateContentPage(int board_no, Model model) {

    // 글 수정 => escape 불필요(false)
    HashMap<String, Object> map = boardService.getBoard(board_no, false);
    
    model.addAttribute("data", map);
    
    return "board/updateContentPage";
}
```


<br>
<br><br>

# 최신글
---
3시간 이내에 쓴 글만 제목 옆에 new 키워드 뱃지 붙임

<br>

## Service

```java
// BoardService

public ArrayList<HashMap<String, Object>> getBoardList() {
    ArrayList<BoardVO> boardVOList = boardSQLMapper.getBoardList();
    
    ArrayList<HashMap<String, Object>> dataList = new ArrayList<>();
    
    for(BoardVO boardVO : boardVOList) {
        int memberNo = boardVO.getMember_no();	// 작성자 번호			
        
        // SELECT * FROM FP_Member WHERE member_no = #{no}
        MemberVO memberVO = memberSQLMapper.getMemberByNo(memberNo);
        
        HashMap<String, Object> map = new HashMap<>();
        map.put("memberVO", memberVO);
        map.put("boardVO", boardVO);
        
        // 게시글 작성시간이 (현재시간-3시간) 보다 클 때(숫자로 변환하여 연산)
        Date writeDate = boardVO.getBoard_writedate();
        long writeTime = writeDate.getTime();
        
        long currentTime = System.currentTimeMillis();
        long targetTime = currentTime - 1000 * 60 * 60 * 3;
        
        if(writeTime > targetTime) {
            map.put("newKeyword", true);
        }        
        dataList.add(map);
    }
    return dataList;
}
```

<br><br>


## JSP
최신글에만 제목 옆에 bootstrap new 뱃지 붙임

```jsp
<%-- mainPage.jsp--%>
<td>
    <a href="./readContentPage?board_no=${data.boardVO.board_no }">${data.boardVO.board_title }</a>
    <c:if test="${!empty data.newKeyword }">
        <span class="badge bg-danger">new</span>
    </c:if>
</td>
```


<br>
<br><br>

# 검색
---
select 박스를 이용하여 제목/내용/닉네임으로 게시글 검색 기능 작성<br>
<br>

## DB

```sql
--총 4개의 쿼리 필요

--전체 검색
SELECT * FROM FP_Board
ORDER BY board_no DESC;

--제목 검색
SELECT *
FROM FP_Board
WHERE board_title LIKE '%하하%'
ORDER BY board_no DESC;

--내용 검색
SELECT *
FROM FP_Board
WHERE board_content LIKE '%하하%'
ORDER BY board_no DESC;

--닉네임 검색
--1.join하는 경우
SELECT *
FROM FP_Board, FP_Member
WHERE FP_Board.member_no = FP_Member.member_no
AND FP_Member.member_nick LIKE '%rrr3%'
ORDER BY FP_Board.board_no DESC;

--2.subquery 사용하는 경우
SELECT *
FROM FP_Board
WHERE member_no IN(
	SELECT member_no
	FROM FP_Member
	WHERE member_nick LIKE '%rrr3%'
)
ORDER BY board_no DESC;


--동적쿼리를 사용하면 위 4개의 쿼리를 하나의 쿼리로 합칠 수 있음
--동적쿼리를 위한 쿼리
SELECT fb.* FROM FP_BOARD fb, FP_MEMBER fm 
WHERE fb.member_no = fm.member_no
--AND fb.board_title LIKE '%하하%'
--AND fb.board_content LIKE '%하하%'
--AND fm.member_nick LIKE '%하하하%'
ORDER BY fb.board_no DESC
;
```

<br><br>

## Mapper
Mybatis는 기본적으로 파라미터를 1개만 받을 수 있음<br>
<br>
파라미터가 여러 개인 경우<br>
1. 파라미터들을 담을 클래스를 만들어 넣음
2. `map`에 넣어 전달
3. `@Param("key값")` 어노테이션 사용 => 내부적으로 `HashMap` 생성됨

<br>

```java
// BoardSQLMapper interface

public ArrayList<BoardVO> getBoardList(@Param("searchOption") String searchOption, 
					@Param("searchWord") String searchWord);
```

<br>
Mybatis는 xml 파일에서 if문 사용할 수 있음(jsp 문법과 헷갈리지 않도록 주의)
- 공통되는 부분은 if 문 밖으로 뺄 수 있음
- 반복문도 가능(foreach 문)

```xml
<!-- BoardSQLMapper.xml -->

<!-- 동적 쿼리 -->
<select id="getBoardList" resultType="com.팀명.프로젝트명.vo.BoardVO">
	SELECT fb.* FROM FP_BOARD fb, FP_MEMBER fm 
	WHERE fb.member_no = fm.member_no
	<if test="searchOption != null">
		<choose>
			<when test="searchOption == 'title'">
				AND fb.board_title LIKE '%'|| #{searchWord} ||'%'
			</when>
			<when test="searchOption == 'content'">
				AND fb.board_content LIKE '%'|| #{searchWord} ||'%'
			</when>
			<when test="searchOption == 'nick'">
				AND fm.member_nick LIKE '%'|| #{searchWord} ||'%'
			</when>		<!-- otherwise도 있음 -->
		</choose>
	</if>
	ORDER BY fb.board_no DESC
</select>
```

<br>
<br>

## Service

```java
// BoardService

public ArrayList<HashMap<String, Object>> getBoardList(String searchOption, String searchWord) {
	ArrayList<HashMap<String, Object>> dataList = new ArrayList<>();
		
	ArrayList<BoardVO> boardVOList = boardSQLMapper.getBoardList(searchOption, searchWord);

	// 기존과 동일한 부분 생략
}
```

<br><br>

## Controller

```java
// BoardController

@RequestMapping("mainPage")
public String mainPage(Model model, String searchOption, String searchWord) {
	System.out.println("시스템 로그] 메인 페이지 실행");
		
	ArrayList<HashMap<String, Object>> dataList = boardService.getBoardList(searchOption, searchWord);
	// 기존과 동일한 부분 생략
}
````

<br><br>

## JSP

```jsp
<%--mainPage.jsp--%>

<form action="./mainPage" method="get">				
<div class="row mt-3">	<%-- 검색 --%>
	<div class="col">
		<select name="searchOption" class="form-select">
			<option value="title">제목</option>
			<option value="content">내용</option>
			<option value="nick">닉네임</option>
		</select>
	</div>
	<div class="col-8">
		<input name="searchWord" type="text" class="form-control" placeholder="검색할 단어를 입력하세요">
	</div>
	<div class="col d-grid">
		<input type="submit" value="검색" class="btn btn-primary">
	</div>
</div>
</form>
```

<br>
<br><br>

# 페이징
---
한 페이지에 게시글 10개씩 출력되도록 작성<br>
<br><br>

## DB

💡 **ROWNUM**<br>
<br>
`WHERE ROWNUM <= 10` ⭕<br>
`WHERE ROWNUM >= 1`  &nbsp;⭕<br>
`WHERE ROWNUM >= 2`  &nbsp;❌<br>
<br>
`ROWNUM`은 WHERE절로 테이블을 만들고 나서 뽑아오는 것<br>
`ROWNUM` 1이 만들어지지 않은 상태에서 2부터 뽑아오려고해서 실행 안 됨<br>
<br>
FROM절 서브쿼리 : 쿼리의 실행 순서를 제어할 수 있음(FROM절에 있는게 먼저 실행됨)
<br><br>

```sql
--페이징 쿼리(MySQL, PostgreSQL에서는 ROWNUM 대신 LIMIT 사용 => 같은 동작은 아님)

SELECT t1.*, ROWNUM FROM (
	SELECT * FROM FP_BOARD ORDER BY board_no DESC
) t1
WHERE ROWNUM <= 10;


--위 쿼리를 서브쿼리로 사용하여 ROWNUM이 이미 붙어있는 인라인 뷰를 만듦
--ROWNUM을 하나의 컬럼처럼 사용가능, 중간부터 값 가져올 수 있음
SELECT t2.* FROM (
	SELECT t1.*, ROWNUM AS rnum FROM (
		SELECT * FROM FP_BOARD ORDER BY board_no DESC
	) t1
)t2
WHERE t2.rnum >= 11 AND t2.rnum <= 20;


--한 페이지에 10개씩 나오는 게시판의 1페이지
SELECT t2.* FROM (
	SELECT t1.*, ROWNUM AS rnum FROM (
		SELECT * FROM FP_BOARD ORDER BY board_no DESC
	) t1
)t2
WHERE t2.rnum >= (1-1)*10 + 1
AND t2.rnum <= 1 * 10;


--검색과 페이징 쿼리
SELECT t2.* FROM (
	SELECT t1.*, ROWNUM AS rnum FROM (
		SELECT fb.* FROM FP_BOARD fb, FP_MEMBER fm 
		WHERE fb.member_no = fm.member_no
		--AND fb.board_title LIKE '%하하%'
		--AND fb.board_content LIKE '%하하%'
		--AND fm.member_nick LIKE '%rrr3%'
		ORDER BY fb.board_no DESC
	)t1
)t2
WHERE t2.rnum >= (1-1)*10 + 1
AND t2.rnum <= 1 * 10;
;
```

<br><br>

## Mapper

```java
// BoardSQLMapper interface

public ArrayList<BoardVO> getBoardList(
		@Param("searchOption") String searchOption, 
		@Param("searchWord") String searchWord,
		@Param("pageNum") int pageNum); 

// 총 개수 카운팅
public int getBoardCount(
		@Param("searchOption") String searchOption, 
		@Param("searchWord") String searchWord);
```

<br>

xml에서 크기 비교할 때 `<=, >=, <, >`의 꺽쇠를 태그로 인식함<br>
=> 특수 문자 처리 필요<br>
<br>
`<![CDATA[ ]]>` 이용 : `[ ]` 안에 들어가는 문자는 xml 문법을 무시하고 문자 그대로 인지<br>
`[ ]` 안에서는 태그가 안 먹히기 때문에 escape가 필요한 부분에만 사용<br>

```xml
<!-- BoardSQLMapper.xml -->

<select id="getBoardList" resultType="com.팀명.프로젝트명.vo.BoardVO">
    SELECT t2.* FROM (
        SELECT t1.*, ROWNUM AS rnum FROM (
            SELECT fb.* FROM FP_BOARD fb, FP_MEMBER fm 
            WHERE fb.member_no = fm.member_no
            <if test="searchOption != null">
                <choose>
                    <when test="searchOption == 'title'">
                        AND fb.board_title LIKE '%'|| #{searchWord} ||'%'
                    </when>
                    <when test="searchOption == 'content'">
                        AND fb.board_content LIKE '%'|| #{searchWord} ||'%'
                    </when>
                    <when test="searchOption == 'nick'">
                        AND fm.member_nick LIKE '%'|| #{searchWord} ||'%'
                    </when>
                </choose>
            </if>
            ORDER BY fb.board_no DESC) t1
        ) t2
    
    <![CDATA[ 
    WHERE t2.rnum >= (#{pageNum}-1) * 10 + 1
    AND t2.rnum <= #{pageNum} * 10
    ]]>
</select>


<select id="getBoardCount" resultType="int">
    SELECT COUNT(*)
    FROM FP_BOARD fb, FP_MEMBER fm
    WHERE fb.MEMBER_NO = fm.MEMBER_NO
    <if test="searchOption != null">
        <choose>
            <when test="searchOption == 'title'">
                AND fb.board_title LIKE '%'|| #{searchWord} ||'%'
            </when>
            <when test="searchOption == 'content'">
                AND fb.board_content LIKE '%'|| #{searchWord} ||'%'
            </when>
            <when test="searchOption == 'nick'">
                AND fm.member_nick LIKE '%'|| #{searchWord} ||'%'
            </when>
        </choose>
    </if>
</select>
```

<br><br>

## Service

```java
// BoardService

public ArrayList<HashMap<String, Object>> getBoardList(
		String searchOption, String searchWord, int pageNum) {
	ArrayList<HashMap<String, Object>> dataList = new ArrayList<>();
		
	ArrayList<BoardVO> boardVOList = boardSQLMapper.getBoardList(searchOption, searchWord, pageNum);

	// 기존과 동일한 부분 생략
 }

public int getBoardCount(String searchOption, String searchWord) {
	return boardSQLMapper.getBoardCount(searchOption, searchWord);
}
```

<br><br>


## Controller
전달되지 않은 파라미터는 스프링에서 null로 인지<br>
=>기본타입은 null이 들어갈 수 없어 에러남<br>
<br>
`@RequestParam` Annotation 사용<br>

```java
/* 키가 pageNum인 값을 받아와 int pageNum에 넣음, 넘어온 값이 없으면 defaultValue인 1로 지정
문법상 "1"로 표기했지만 int임 */

@RequestParam(value = "pageNum", defaultValue = "1") int pageNum
```

<br><br>

```java
// BoardController

@RequestMapping("mainPage")
public String mainPage(
		Model model,
		String searchOption,
		String searchWord, 
		@RequestParam(value = "pageNum", defaultValue = "1") int pageNum) {
	System.out.println("시스템 로그] 메인 페이지 실행");
		
	ArrayList<HashMap<String, Object>> dataList = boardService.getBoardList(searchOption, searchWord, pageNum);
		
	int count = boardService.getBoardCount(searchOption, searchWord);
	// 10미만의 게시글이 있는 마지막 페이지 개수까지 포함하기 위해 ceil(올림함수) 사용
	// 총 페이지 수
	int totalPageCount  = (int) Math.ceil(count / 10.0);	

	// 1~5, 6~10 등으로 페이지목록 나눔
	int startPage = ((pageNum-1)/5)*5 + 1;
	int endPage = ((pageNum-1)/5 + 1) * (5);
		
	if(endPage > totalPageCount) {
		endPage = totalPageCount;
	}

	// 링크에 검색 결과 파라미터 추가
	String additionalParam = "";

	// URL encoding -> euc-kr 표준 문자가 아닌 값이 존재할 때 처리
	if(searchOption != null) {
		try {
			searchOption = URLEncoder.encode(searchOption, "utf-8");
		} catch(Exception e) {
			e.printStackTrace();
		}
		additionalParam += "&searchOption=" + searchOption;
	}
	
	if(searchWord != null) {
		try {
			searchWord = URLEncoder.encode(searchWord, "utf-8");
		} catch(Exception e) {
			e.printStackTrace();
		}
		additionalParam += "&searchWord=" + searchWord;
	}		
		
	// model.addAttribute("count", count);	글 개수 출력할거면 쓸 것
	model.addAttribute("startPage", startPage);
	model.addAttribute("endPage", endPage);
	model.addAttribute("currentPage", pageNum);
	model.addAttribute("totalPageCount", totalPageCount);		
	model.addAttribute("additionalParam", additionalParam);		
	model.addAttribute("dataList", dataList);	
	return "board/mainPage";
}
```

<br>
<br>

## JSP

```jsp
<%-- mainPage.jsp --%>

<ul class="pagination mb-0">
<c:choose>
    <c:when test="${startPage <= 1 }">
        <li class="page-item disabled page-link">&lt;</li>	    	
    </c:when>
    <c:otherwise>
    <li class="page-item">
            <a class="page-link" href="./mainPage?pageNum=${startPage-1 }${additionalParam }">&lt;</a>
    </li>							    	
    </c:otherwise>
</c:choose>
<c:forEach begin="${startPage }" end="${endPage }" var="i">
    <c:choose>
        <c:when test="${currentPage == i }">
            <li class="page-item active">
                <a class="page-link" href="./mainPage?pageNum=${i }${additionalParam }">${i }</a>
                </li>		
        </c:when>
        <c:otherwise>
            <li class="page-item">
                <a class="page-link" href="./mainPage?pageNum=${i }${additionalParam }">${i }</a>
                </li>
        </c:otherwise>
    </c:choose>							   
</c:forEach>
<c:choose>
    <c:when test="${endPage >= totalPageCount }">
        <li class="page-item disabled page-link">&gt;</li>	    	
    </c:when>
    <c:otherwise>
        <li class="page-item">
            <a class="page-link" href="./mainPage?pageNum=${endPage+1 }${additionalParam }">&gt;</a>
        </li>							    	
    </c:otherwise>
</c:choose>
</ul>
```

<br>
<br><br>


# 파일 업로드
---
업로드 파일 저장용 폴더 만들기(서버폴더) : C:\uploadfolder<br>



## XML 설정
<br>
**server.xml**<br>
하단에 upload된 파일 Context path 추가

```xml
<Context docBase="C:\uploadfolder" path="/upload" reloadable="false"/>
```

* path : 외부에서 접속하는 경로(링크)
* docBasc : 실제로 접근되는 경로

`localhost:8181/upload/` 로 요청들어오면 C:\uploadfolder로 접근<br>
`<img src="/upload/2022/01/19/이미지명.jpg">` 으로 이미지 띄움<br>
<br>

> resource로서의 이미지와 구별할 것(`webapp/resources/img`의 이미지)

<br>

<br>
**pom.xml**<br>
multipart/form-data 을 파싱할 세팅을 해줘야 함

```xml
<!-- 업로드용 파일 파서... -->
<dependency>
	<groupId>commons-fileupload</groupId>
	<artifactId>commons-fileupload</artifactId>
	<version>1.3.3</version>
</dependency>	
```

<br>
<br>
**servlet-context.xml**
- bean 등록(파일 받을 객체 필요)
- id는 무조건 "multipartResolver" 여야 함
- CommonsMultipartResolver 객체는 @Autowired 없이 알아서 동작
- maxUploadSize는 byte 단위(현재 100MB)

```xml
<!-- 파일 업로드 관련 추가 빈 -->
<beans:bean id="multipartResolver" 
class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
	<beans:property name="maxUploadSize" value="100000000"></beans:property>
</beans:bean>
```

<br><br>
<br>

## DB
게시글과 업로드한 이미지 url을 연결하는 table 필요<br>
<br><br>

**ERD**

<center><img src="https://user-images.githubusercontent.com/57750308/150634615-45d35c7c-ceb5-4ac6-b748-6bc66112cfcf.png"></center>

<br>

```sql
--게시판 이미지 테이블
DROP TABLE FP_BoardImage;
CREATE TABLE FP_BoardImage (
	image_no NUMBER,
	board_no NUMBER,
	image_url VARCHAR2(300),
	image_original_filename VARCHAR2(400)
);

DROP SEQUENCE FP_BoardImage_seq;
CREATE SEQUENCE FP_BoardImage_seq;

--Board 테이블에도 동시에 INSERT 해야하므로 Board seq 	받아옴
SELECT FP_Board_seq.nextval FROM dual;

--context path는 url값에 포함하지 않았음
INSERT INTO FP_BoardImage VALUES(
	FP_BoardImage_seq.nextval,
	3,
	'2022/01/19/306c8ede-f02a-4558-954f-77e107be8d09_1642558957170.jpg',
	'jjang.jpg'
);

--FK인 board_no로 SELECT
SELECT * FROM FP_BoardImage
WHERE board_no = 3;
```

<br>
<br>

## VO
FP_BoardImage 테이블의 속성과 동일한 필드명을 갖는 VO 생성
<br><br>

```java
// BoardImaveVO

package com.팀명.프로젝트명.vo;

public class BoardImageVO {
	private int image_no;
	private int board_no;
	private String image_url;
	private String image_original_filename;
	
	// 생성자 및 getter/setter 작성
}
```

<br><br>

## Mapper

```java
// BoardSQLMapper interface

// 보드 테이블 PK 생성
public int createBoardPK();

// 이미지 테이블에 INSERT
public void insertImage(BoardImageVO vo);

// 이미지 테이블에서 board_no로 SELECT
public ArrayList<BoardImageVO> getImageListByBoardNo(int boardNo);
```

<br>

```xml
<!-- BoardSQLMapper.xml -->

<!-- 보드 테이블 PK 생성 -->
<select id="createBoardPK" resultType="int">
    SELECT FP_Board_seq.nextval
    FROM dual
</select>

<insert id="insertBoard">
    INSERT INTO FP_Board VALUES (
    #{board_no},		<!-- FP_Board_seq.nextval => #{board_no}로 수정 -->
    #{member_no},
    #{board_title},
    #{board_content},
    0,
    SYSDATE
    )
</insert>

<!-- 이미지 테이블에 INSERT -->
<insert id="insertImage">
    INSERT INTO FP_BoardImage VALUES(
        FP_BoardImage_seq.nextval,
        #{board_no},
        #{image_url},
        #{image_original_filename}
    )
</insert>

<!-- board_no로 이미지테이블에서 SELECT -->
<select id="getImageListByBoardNo" resultType="com.팀명.프로젝트명.vo.BoardImageVO">
    SELECT *
    FROM FP_BoardImage
    WHERE board_no = #{boardNo};
</select>
```

<br><br>

## Service

```java
// BoardService

public void writeContent(BoardVO vo, ArrayList<BoardImageVO> boardImageVOList) {

	int boardNo = boardSQLMapper.createBoardPK();
		
	vo.setBoard_no(boardNo);
	boardSQLMapper.insertBoard(vo);
		
	for(BoardImageVO boardImageVO : boardImageVOList) {
		boardImageVO.setBoard_no(boardNo);
		boardSQLMapper.insertImage(boardImageVO);
	}
}

public HashMap<String, Object> getBoard(int board_no, boolean isEscape) {

	// 기존과 동일한 부분 생략

	ArrayList<BoardImageVO> boardImageVOList = 
		boardSQLMapper.getImageListByBoardNo(board_no);
		
		
	map.put("memberVO", memberVO);
	map.put("boardVO", boardVO);
	map.put("boardImageVOList", boardImageVOList);
```

<br><br>

## Controller
* 사용자들이 업로드한 파일을 uploadfolder에 저장
  * 동일한 파일명을 가진 파일이 업로드될 수 있음
    * uploadfolder에 덮어씌워짐
  * 임의의 랜덤id + 시간을 파일명으로 하여 중복되지 않게 저장
  * 날짜(시간)별로 폴더를 만들어 관리
    * `c:/uploadfolder/2022/01/19/임의 파일명.jpg`

<br>

```java
// BoardController

@RequestMapping("writeContentProcess")
/* 업로드된 파일은 배열(MultipartFile[])로 받음
writeContentPage.jsp : <input type="file" accept="image/*" multiple name="uploadFiles"> */
public String writeContentProcess(BoardVO param, MultipartFile[] uploadFiles, HttpSession session) {
    System.out.println("시스템 로그] 글쓰기 프로세스 실행");
    
    ArrayList<BoardImageVO> boardImageVOList = new ArrayList<>();

    String uploadFolder = "C:/uploadfolder/";
    
    // 파일 업로드
    if(uploadFiles != null) {
        for(MultipartFile uploadFile : uploadFiles) {
            // 업로드된 파일이 없어도 꼭 한 번은 루핑 돌기 때문에 isEmpty로 체크
            if(uploadFile.isEmpty()) {
                continue;
            }
            
            // 날짜 별 폴더 생성 2022/01/19
            Date today = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd/"); 
            String folderPath= sdf.format(today);
            
            // file뿐만이 아닌 folder까지 컨트롤
            // C:/uploadfolder/2022/01/19/
            File todayFolder = new File(uploadFolder + folderPath);
            
            if(!todayFolder.exists()) {
                // path 상위에서부터 없는 폴더 생성
                todayFolder.mkdirs();
            }
            
            // 중복되지 않게 저장해야 함(덮어씀 방지)
            // 방법 : 랜덤  + 시간
            String fileName = "";
            
            // universally unique identifier
            UUID uuid = UUID.randomUUID();				
            fileName += uuid.toString();
            
            long currentTime = System.currentTimeMillis();
            fileName += "_" + currentTime;
            
            // 확장자 추가
            // getOriginalFilename : 업로드한 쪽에서 설정한 파일명				
            String originalFileName = uploadFile.getOriginalFilename();
            String ext = originalFileName.substring(
                    originalFileName.lastIndexOf("."));
            fileName += ext;
            
            try {
                // transferTo(File dest) : dest로 파일을 receive
                uploadFile.transferTo(new File(uploadFolder +
                        folderPath + fileName));
            } catch (Exception e) {
                e.printStackTrace();
            }

            // 서비스에 보내기 위한 데이터 구성
            BoardImageVO boardImageVO = new BoardImageVO();
            boardImageVO.setImage_url(folderPath + fileName);
            boardImageVO.setImage_original_filename(originalFileName);
            
            boardImageVOList.add(boardImageVO);
        }
    }
    MemberVO sessionUser = (MemberVO) session.getAttribute("sessionUser");
    int memberNo = sessionUser.getMember_no();
    param.setMember_no(memberNo);
    
    // Service(class) -> Mapper(interface, XML) -> INSERT
    boardService.writeContent(param, boardImageVOList);
    
    return "redirect:./mainPage";
}
```

=> `MultipartFile[]`에는 이미지가 원본이미지 파일 이름순으로 들어가 있음(오름차순)<br>
=> FP_BoardImage 테이블에도 원본이미지 파일 이름순으로 INSERT됨<br>


<br><br>


## JSP

* `<form>` 태그에 `enctype`(인코딩타입) 설정
  * default는 `application/x-www-form-urlencoded` : url 인코딩 방식`(key=value&key=value)`
  * url 인코딩 방식으로는 파일전송 안 됨
  * `enctype="multipart/form-data"` 로 설정
* method는 반드시 `post`

<br>

```jsp
<%-- writeContentPage.jsp --%>

<%-- accept="image/*" : image파일만 받음, multiple : 파일 여러개 선택 가능 --%>

<form action="./writeContentProcess" method="post" enctype="multipart/form-data">
    작성자 : ${sessionUser.member_nick }<br>
    제목 : <input type="text" name="board_title"><br>
    내용 : <br>
    <textarea rows="10" cols="40" name="board_content"></textarea><br>
    <input type="file" accept="image/*" multiple name="uploadFiles"><br>
    <input type="submit" value="작성완료">
</form>
```

<br>

```jsp
<%-- readContentPage.jsp --%>

이미지 : <br>
<c:forEach items="${data.boardImageVOList }" var="boardImageVO">
	<img src="/upload/${boardImageVO.image_url }"><br>
</c:forEach>
```

<br><br>
<br>

# 비밀번호 암호화
---
사용자들 대부분 비밀번호를 사이트마다 동일하게 설정
* DB 탈취에 의한 유출 위험
* 암호화하여 DB에 저장 필요

<br>
암호
1. 복호화 가능

2. 복호화 불가능
* 암호화 알고리즘을 알아도 복호화가 불가능해야 함
* Hash 알고리즘
  * Hash : 잘게 쪼갠다
  * `ex)1234 -> f(x) 각 자릿 수를 잘개 쪼개서 더함 -> 10`

<br>

* Hash 알고리즘의 특징
  * 복호화가 불가능해야 한다
  * y = f(x)가 성립돼야 한다(동일 알고리즘안에서 x는 항상 y가 나옴)
  * 단방향성(복호화 불가)
  * 암호화 결과가 같은 충돌이 이론적으로 존재

<br>
❓ 해시태그<br>
태그 내용을 해싱하여 숫자로 만들어 검색 속도를 빠르게 함(문자 비교는 속도가 느림)
<br>
<br>

* SHA 사용할 것
  * SHA-256 -> 256bit, SHA-512 -> 512bit, SHA-1 -> 160bit
  * MessageDigest 클래스 : 메세지를 압축, 어떤 x를 넣어도 N bit의 y가 나옴
  * x는 무한대, y는 N bit 자릿수로 한정되어 있음
    * 충돌 발생 가능성

<br><br>

## Commons

```java
// MessageDigestUtil

package com.팀명.프로젝트명.commons;

public class MessageDigestUtil {
	// static 대신 클래스 위에 @Component 달고 @Autowired해서 써도 됨
	public static String getPasswordHashCode(String password) {

		// salt : 암호 뒤에 임의의 문자열을 붙여 원문 추적 어렵게 함
		password = password + "소금후추";		

		String hashCode = null;
		
		// password를 암호화 한다
		try {
			
			MessageDigest messageDigest = 
					MessageDigest.getInstance("SHA-1");	// 160bit로 암호화
			messageDigest.reset();
			
			// 파라미터로 byte 타입 받음 -> 문자 뿐만아니라 파일도 암호화 가능
			messageDigest.update(password.getBytes("UTF-8"));
			
			// 160bit 해시 값 생성(chars.length는 20)
			byte[] chars = messageDigest.digest();
			
			// 모양 예쁘게 만들기(한 자릿수면 앞에 0 붙이기)
			StringBuilder sb = new StringBuilder();
			
			for(int i=0;i<chars.length;i++) {
				// int 값을 넣으면 문자를 return
				String tmp = Integer.toHexString(chars[i] & 0xff);
				
				if(tmp.length() == 1) {
					sb.append("0");
				}
				
				sb.append(tmp);
			}
			hashCode = sb.toString();
			
		} catch(Exception e) {
			e.printStackTrace();
		}
		
		return hashCode;
	}
}
```

<br><br>

## Service

```java
// MemberService : 

public void joinMember(MemberVO vo, int[] hobby_category_no) {

	// member_no(PK) 먼저 생성
	int memberNo = memberSQLMapper.createMemberPK();

	// DB insert
	vo.setMember_no(memberNo);

	// 비밀번호 해싱		
	String password = vo.getMember_pw();
	password = MessageDigestUtil.getPasswordHashCode(password);
	vo.setMember_pw(password);
		
	memberSQLMapper.joinMember(vo);

	// 기존과 동일한 부분 생략
}


public MemberVO login(MemberVO vo) {
		
	// 비밀번호 해싱
	String password = vo.getMember_pw();
	password = MessageDigestUtil.getPasswordHashCode(password);
	vo.setMember_pw(password);
	
	MemberVO result = memberSQLMapper.getMemberByIdAndPw(vo);
		
	return result;
}
```

<br><br>
<br>

# 이메일 인증
---
회원가입 시 인증키 생성 후 기재한 이메일로 인증 메일 전송<br>
사용자가 메일 내 인증 링크를 클릭해야 인증 완료/로그인 가능<br>
<br>
<br>


## XML 설정
<br>
**pom.xml**

```xml
<!-- Mail 관련 라이브러리 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-support</artifactId>
    <version>5.0.7.RELEASE</version>
</dependency>

<dependency>
    <groupId>javax.mail</groupId>
    <artifactId>mail</artifactId>
    <version>1.4.7</version>
</dependency>
```

<br>
<br>

**root-context.xml**
* 메일 보내는 클래스 bean 등록
* property 설정으로 setter 호출하여 보내는 메일주소, pw 세팅

```xml
<!-- 메일 관련 인스턴스 추가 -->
<bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl">
    <property name="host" value="smtp.gmail.com" />
    <property name="port" value="587" />
    <property name="username" value="메일주소@gmail.com" />
    <property name="password" value="비밀번호" />
    <!-- email 요청시는 SMTP -->
    <property name="javaMailProperties">
    <props>
        <prop key="mail.transport.protocol">smtp</prop>
        <prop key="mail.smtp.auth">true</prop>
        <prop key="mail.smtp.starttls.enable">true</prop>
        <prop key="mail.debug">false</prop>
        <prop key="mail.smtp.ssl.trust">smtp.gmail.com</prop>
        <prop key="mail.smtp.ssl.protocols">TLSv1.2</prop>
    </props>
    </property>
</bean>
```

<br><br>



## DB
<br>
**ERD**

<center><img src="https://user-images.githubusercontent.com/57750308/150635728-742e748f-6c4c-4976-914c-f5d24fafcdec.png"></center>

<br>

```sql
--회원 이메일 인증 테이블
DROP TABLE FP_MailAuth;
CREATE TABLE FP_MailAuth (
	mailauth_no NUMBER,
	member_no NUMBER,
	mailauth_key VARCHAR2(400),
	mailauth_complete VARCHAR2(1),
	mailauth_date DATE
);

DROP SEQUENCE FP_MailAuth_seq;
CREATE SEQUENCE FP_MailAuth_seq;


--TEST
--가입시 인증 안 된 상태이므로
--mailauth_complete='N', mailauth_date=NULL
INSERT INTO FP_MailAuth VALUES (
	FP_MailAuth_seq.nextval,
	1,
	'키 번호....',
	'N',
	NULL
);

--키 번호로 조건 검색
UPDATE FP_MailAuth
SET mailauth_complete = 'Y', mailauth_date = SYSDATE
WHERE mailauth_key = '키 번호....';

SELECT * FROM FP_MailAuth;


--로그인 쿼리
SELECT * FROM FP_Member fmb, FP_MailAuth fma
WHERE fmb.member_no = fma.member_no
AND fmb.member_id = 아이디'
AND fmb.member_pw = '해쉬 값'
AND fma.mailauth_complete = 'Y';
```

<br><br>

## Mapper

```java
// MemberSQLMapper interface

// 메일 인증 관련
public void insertMailAuth(MailAuthVO vo);
public void updateMailAuthComplete(String authKey);
```

<br>

```xml
<!-- MemberSQLMapper.xml -->

<insert id="insertMatilAuth">
	INSERT INTO FP_MailAuth VALUES (
	FP_MailAuth_seq.nextval,
	#{member_no},
	#{mailauth_key},
	'N',
	NULL
)		
</insert>	

<!-- 메일 인증 완료 -->
<update id="updateMailAuthComplete">
	UPDATE FP_MailAuth
	SET mailauth_complete = 'Y', mailauth_date = SYSDATE
	WHERE mailauth_key = #{authKey}
</update>

<!-- 로그인 시 인증 여부 확인 -->
<select id="getMemberByIdAndPw" resultType="com.팀명.프로젝트명.vo.MemberVO">
	SELECT * FROM FP_Member fmb, FP_MailAuth fma
	WHERE fmb.member_no = fma.member_no
	AND fmb.member_id = #{member_id}
	AND fmb.member_pw = #{member_pw}
	AND fma.mailauth_complete = 'Y'
</select>
```

<br><br>


## Commons
메일을 발송하는 JavaMailSender의 send() 메소드 호출시 딜레이 존재<br>
=> 메일보내는 부분 쓰레드로 처리<br>

```java
// MailSenderThread

package com.팀명.프로젝트명.commons;

import javax.mail.internet.MimeMessage;

import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;

public class MailSenderThread extends Thread {
	
	private JavaMailSender javaMailSender;
	private String to;
	private String message;
	
	public MailSenderThread(JavaMailSender javaMailSender,	String to, String message) {
		this.javaMailSender = javaMailSender;
		this.to = to;
		this.message = message;
	}
	
	public void run() {
		// 인증키를 메일로 전송
		try {
			MimeMessage mimeMessage = javaMailSender.createMimeMessage();
			// wrapper 클래스(MimeMessage를 wrapping)
			MimeMessageHelper mimeMessageHelper = 
					new MimeMessageHelper(mimeMessage, true, "UTF-8");
			
			mimeMessageHelper.setSubject("회원가입을 축하드립니다.");
			mimeMessageHelper.setText(message, true);
			
			// setFrom 첫 번째 파라미터는 꼭 영어로 해야 함(한글X)
			mimeMessageHelper.setFrom("qwer", "FP 관리자");	// 보내는 사람: FP 관리자
			mimeMessageHelper.setTo(to);
			
			javaMailSender.send(mimeMessage);
		} catch(Exception e) {
			e.printStackTrace();
		}
	}
}
```

<br>
<br>


## Service
회원가입하면 3개 테이블에 INSERT됨(FP_Member, FP_MemberHobby, FP_MailAuth)

```java
// MemberService

public void joinMember(MemberVO vo, int[] hobby_category_no) {

    // 기존과 동일한 부분 생략

    // 메일 인증 관련
    // UUID도 특정 길이 문자 반환을 해서 충돌 위험은 있음
    UUID uuid = UUID.randomUUID();
    String authKey = uuid.toString();
    
    MailAuthVO mailAuthVO = new MailAuthVO();
    mailAuthVO.setMailauth_key(authKey);
    mailAuthVO.setMember_no(memberNo);
    
    memberSQLMapper.insertMailAuth(mailAuthVO);
    
    
    // 인증키를 메일로 전송
    String text= "";
    text += "회원가입을 축하드립니다. 아래 링크를 클릭하셔서 메일 인증 완료를 부탁드립니다.<br>";
    text += "<a href='http://localhost:8181/프로젝트명/member/mailAuthProcess?authKey=" + authKey + "'>메일 인증하기</a>";
    
    MailSenderThread mst = new MailSenderThread(
            javaMailSender, vo.getMember_email(), text); 
    
    mst.start();
}

public void authMail(String key) {
	memberSQLMapper.updateMailAuthComplete(key);
}
```

<br><br>

## Controller

```java
// MemberController :

@RequestMapping("mailAuthProcess")
public String mailAuthProcess(String authKey) {		
	memberService.authMail(authKey);

	return "member/authMailProcessComplete";
}
```

<br><br>

## JSP


```jsp
<%-- joinMemberComplete.jsp --%>

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	회원가입을 축하드립니다.<br>
	가입하신 이메일로 인증 메일을 전송하였습니다.<br>
	메일 확인 후 링크를 클릭하셔서 인증 후 이용가능합니다.<br>
	메일 전송은 3~5분 정도 소요될 수 있습니다.<br>
	<a href="./loginPage">로그인 페이지로</a> 
</body>
</html>
```

<br>

```jsp
<%-- authMailProcessComplete.jsp --%>

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	메일 인증이 완료되었습니다.<br>
	로그인 후 이용 가능 합니다.<br>
	<a href="./loginPage">로그인 페이지로</a>
</body>
</html>
```

<br>

```jsp
<%-- loginFail.jsp --%>

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	아이디 혹은 비밀번호를 확인해주세요. 혹은 메일인증 확인해 주세요.<br>
	<a href="./loginPage">로그인 페이지로</a>
</body>
</html>
```

<br><br>
<br>

# 좋아요
---
게시글에 하트 아이콘을 추가하여 좋아요 기능 작성<br>
한 번 누르면 좋아요, 추가로 누르면 좋아요 해제<br>
<br>
<br>

## DB
연결의 의미가 있는 테이블(누가 무엇을 어떻게 했다)<br>
상품 구매, 장바구니, 찜하기, 스크랩, 친구추가 등과 비슷한 구조의 테이블<br>
<br><br>

**ERD**

<center><img src="https://user-images.githubusercontent.com/57750308/150636587-2233e74d-3da4-48ba-b12f-7282a583d08b.png"></center>

<br>

```sql
--좋아요 테이블
--member_no, board_no는 FK
DROP TABLE FP_BoardLike;
CREATE TABLE FP_BoardLike (
	like_no NUMBER,
	member_no NUMBER,
	board_no NUMBER,
	like_date DATE
);


DROP SEQUENCE FP_BoardLike_seq;
CREATE SEQUENCE FP_BoardLike_seq;


--테스트
--좋아요했을 때 INSERT
INSERT INTO FP_BoardLike VALUES (
	FP_BoardLike_seq.nextval,
	1,
	1,
	SYSDATE
)

--좋아요 취소
DELETE FROM FP_BoardLike 
WHERE member_no = 1
AND board_no = 1;

--특정 게시글의 총 좋아요 수
SELECT COUNT(*)
FROM FP_BoardLike 
WHERE board_no = 1;

--1번회원이 1번 글에 좋아요를 했는지 조회
--정상적인 경우 : 0 or 1
--비정상적인 경우 : 2 이상(버그가 생겨서 두 번 이상 INSERT 됨)
SELECT COUNT(*)
FROM FP_BoardLike 
WHERE member_no = 1
AND board_no = 1;
```

<br><br>

## VO
FP_BoardLike 테이블과 동일한 속성을 갖는 VO 작성


```java
public class BoardLikeVO {
	private int like_no;
	private int member_no;
	private int board_no;
	private Date like_date;

	// 생성자 및 getter/setter 작성
}
```

<br><br>

## Mapper

```java
// BoardSQLMapper interface

// 좋아요 테이블
public void insertLike(BoardLikeVO vo);
public void deleteLike(BoardLikeVO vo);
public int getTotalLikeCount(int board_no);
public int getMyLikeCount(BoardLikeVO vo);
```

<br>

```xml
<!-- BoardSQLMapper.xml -->

<!-- 좋아요 테이블 -->
<insert id="insertLike">
    INSERT INTO FP_BoardLike VALUES (
    FP_BoardLike_seq.nextval,
    #{member_no},
    #{board_no},
    SYSDATE
    )	
</insert>

<delete id="deleteLike">
    DELETE FROM FP_BoardLike 
    WHERE member_no = #{member_no}
    AND board_no = #{board_no}	
</delete>

<select id="getTotalLikeCount" resultType="int">
    SELECT COUNT(*)
    FROM FP_BoardLike 
    WHERE board_no = #{board_no}	
</select>

<select id="getMyLikeCount" resultType="int">
    SELECT COUNT(*)
    FROM FP_BoardLike
    WHERE member_no = #{member_no}
    AND board_no = #{board_no}
</select>
```

<br><br>

## Service
좋아요와 좋아요 취소 하나의 메소드로 작성
<br><br>

```java
// BoardService

// 좋아요 or 좋아요 취소
public void doLike(BoardLikeVO vo) {
	int count = boardSQLMapper.getMyLikeCount(vo);
	
	if(count > 0) {
		boardSQLMapper.deleteLike(vo);
	} else {
		boardSQLMapper.insertLike(vo);
	}
}

// 게시글의 총 좋아요 개수 표시
public int getTotalLikeCount(int boardNo) {
		
	return boardSQLMapper.getTotalLikeCount(boardNo);
}

// 사용자의 특정 게시글의 좋아요 카운트	
public int getMyLikeCount(BoardLikeVO vo) {
	return boardSQLMapper.getMyLikeCount(vo);
}
```

<br>
<br>

## Controller

```java
// BoardController

@RequestMapping("likeProcess")
public String likeProcess(BoardLikeVO param, HttpSession session) {
	// 행위자 정보는 꼭 세션에서 가져올 것
	MemberVO sessionUser = (MemberVO) session.getAttribute("sessionUser");
	int memberNo = sessionUser.getMember_no();
	param.setMember_no(memberNo);
		
	boardService.doLike(param);
		
	return "redirect:./readContentPage?board_no=" + param.getBoard_no();
}

@RequestMapping("readContentPage")
public String readContentPage(int board_no, Model model, HttpSession session) {
    boardService.increaseReadCount(board_no);
    
    HashMap<String, Object> map = boardService.getBoard(board_no, true);
    
    model.addAttribute("data", map);
    
    // 게시글의 총 좋아요 수
    int totalLikeCount = boardService.getTotalLikeCount(board_no);
    model.addAttribute("totalLikeCount", totalLikeCount);
    
    // 로그인인한 회원의 좋아요 여부 확인
    MemberVO sessionUser = (MemberVO) session.getAttribute("sessionUser");
    if(sessionUser != null) {
        BoardLikeVO boardLikeVO = new BoardLikeVO();
        boardLikeVO.setMember_no(sessionUser.getMember_no());
        boardLikeVO.setBoard_no(board_no);
        
        int myLikeCount = boardService.getMyLikeCount(boardLikeVO);
        
        model.addAttribute("myLikeCount", myLikeCount);
    } 
    return "board/readContentPage";
}
```

<br><br>

## JSP
bootstrap의 하트 아이콘 사용

```jsp
<%-- readContentPage.jsp --%>

<%-- 기존과 동일한 내용 생략 --%>

<c:if test="${!empty sessionUser }">
    <c:choose>
        <c:when test="${myLikeCount > 0 }">	<%-- 좋아요를 누른 경우 색이 채워진 하트 --%>
            <a href="./likeProcess?board_no=${data.boardVO.board_no }"><i class="bi bi-heart-fill fs-1 text-danger"></i></a>		
        </c:when>
        <c:otherwise>	<%-- 좋아요를 해제한 경우 색이 빈 하트 --%>
            <a href="./likeProcess?board_no=${data.boardVO.board_no }"><i class="bi bi-heart fs-1 text-danger"></i></a>	
        </c:otherwise>
    </c:choose>
<br>

</c:if>
좋아요 수 : ${totalLikeCount }
```

<br>
<br><br>

# Interceptor(인터셉터)
---
최후에 작업해야하는 내용<br>
특정 요청을 중간에서 가로채 작업 후 목적지로 보내던가 돌려보냄<br>
<br>

`ex)로그인하지 않은 사용자가 글쓰기/수정 페이지에 링크로 접근`<br>
`=> 컨트롤러에서 일일이 session에 접속정보있는지 확인해야 함`<br>
`=> 중간에 인터셉터를 둬 인터셉터에서만 로그인여부 확인(톰캣의 filter와 비슷)`<br>

<br>
<br>

## XML 설정
**servlet-context.xml**
* `/board/*`로 맵핑하여 `/board/~~`는 전부 인터셉터가 가로챔
* 다만, 로그인이 없어도 사용가능한 `/board/mainPage, /board/readContentPage`는 제외

```xml
<!-- 인터셉터 설정 -->
<interceptors>
    <interceptor>
        <mapping path="/board/*"/>
        <exclude-mapping path="/board/mainPage"/>
        <exclude-mapping path="/board/readContentPage"/>
        <beans:bean class="com.팀명.프로젝트명.interceptor.AuthInterceptor"></beans:bean>
    </interceptor>
</interceptors>
```

<br>
<br>

## Interceptor

```java
// AuthInterceptor

package com.팀명.프로젝트명.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.ModelAndViewDefiningException;
import org.springframework.web.servlet.mvc.WebContentInterceptor;

public class AuthInterceptor extends WebContentInterceptor{
	// 오버라이딩
	public boolean preHandle(
			HttpServletRequest request, 
			HttpServletResponse response, 
			Object handler) throws ModelAndViewDefiningException {

		// 로그인하지 않았으면 로그인이 필요한 페이지임을 알림
		
		// request.getSession() => return HttpSession 인스턴스
		if(request.getSession().getAttribute("sessionUser") == null) {
			ModelAndView mv = new ModelAndView();
			mv.setViewName("member/loginRequired");	// forwarding할 곳 지정
			
			// exception을 발생시켜 forwarding함
			throw new ModelAndViewDefiningException(mv);
		}
		return true;	// 원래 목적지로 감
	}
}
```

<br><br>

## JSP

```jsp
<%-- loginRequired.jsp --%>

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	로그인하셔야 접근 가능한 페이지입니다.<br>
	<a href="../member/loginPage">로그인 페이지로</a>
</body>
</html>
```

<br><br>

# 유효성 검사(JavaScript)
---
jsp에서 `null`값을 submit하면 `NullPointerException` 발생<br>
버튼을 이용하여 JavaScript에서 `null`값이 담긴 파라미터 넘어가지 않도록 방지<br>
<br>
<br>
**JavaScript**
* 응답받은 HTML소스(JS 포함)를 웹브라우저가 해석하여 화면에 그림
* JavaScript는 client가 실행

<br><br>

## JSP

```jsp
<%-- joinMemberPage.jsp --%>

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script src="https://code.jquery.com/jquery-3.6.0.js" integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk=" crossorigin="anonymous"></script>
<script>
	// jQuery version
	function joinMemberSubmit1() {	
		// 유효성 검사(사용자가 입력한 값이 정상적인 값인지 판단)
		// 정규표현식 사용
		// 영소문자로 시작하여 영소문자 및 숫자로 이루어진 6~20개 사이의 문자
		var regExp = /^[a-z][a-z0-9]{5,19}$/g;
		
		// 위 정규표현식에 부합하는지 true/false 리턴
		//regExp.test(text);
		
		if(!regExp.test($("#inputId").val())) {
			alert("아이디는 영소문자로 시작하는 총 6자 ~ 20자 사이의 영소문자/숫자 조합으로 작성하셔야 합니다.");
			$("#inputId").focus();
			return;
		}
		
		
		//var regExp = /^(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,12}$/;

		// 아래처럼 RegExp 객체 생성해서 해도 됨(생성자로 정규식들어감)
		var regExp = RegExp(/^(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,12}$/);
		
		if(!regExp.test($("#inputPw").val())) {
			alert("비밀번호는 영소문자/숫자/특수문자를 포함하는 최소 8자 최대 12자여야 합니다..");
			inputPw.focus();
			return;			
		}

		
		if($("#inputPw").val() != $("#inputPwConfirm").val()) {
			alert("비밀번호와 비밀번호 확인이 일치하지 않습니다.");

			$("#inputPw").val("");
			$("#inputPwConfirm").val("");
			$("#inputPw").focus();
			
			return;
		}
		
		if($("#inputBirth").val() == "") {
			alert("생일을 선택해주세요.")
			$("#inputBirth").focus();
		
			return;
		}
		
		$("#frm1").submit();
	}
	
	// vanilla JS version
	function joinMemberSubmit2() {
		var inputId = document.getElementById("inputId");
		var inputPw = document.getElementById("inputPw");
		var inputPwConfirm = document.getElementById("inputPwConfirm");
		
		var regExp = /^[a-z][a-z0-9]{5,19}$/g;

		if(!regExp.test(inputId.value)) {
			alert("아이디 확인 요망");
			inputId.focus();
			return;
		}

		if(inputPw.value != inputPwConfirm.value) {
			alert("비밀번호와 비밀번호 확인이 일치하지 않습니다.");

			inputPw.value = "";
			inputPwConfirm.value = "";

			inputPw.focus();
			return;
		}
		
		var frm1 = document.getElementById("frm1");
		frm1.submit();
	}

</script>
</head>
<body>
	<h1>회원가입</h1>
	<form id="frm1" action="./joinMemberProcess" method="post">
		ID : <input id="inputId" type="text" name="member_id"><br>
		PW : <input id="inputPw" type="password" name="member_pw"><br>
		PW Confirm : <input id="inputPwConfirm" type="password"><br>
		
		Nickname : <input id="inputNick" type="text" name="member_nick"><br>
		gender :
		<!-- 체크, 라디오, 셀렉트는 value값을 미리 지정해야함 -->
		<input type="radio" name="member_gender" value="M" checked> 남
		<input type="radio" name="member_gender" value="F"> 여<br>
		
		취미 :
		<c:forEach items="${hobbyCategoryList }" var="hobbyCategory">
			<input type="checkbox" name="hobby_category_no" value="${hobbyCategory.hobby_category_no }">${hobbyCategory.hobby_category_name }
		</c:forEach>
		<br>
		
		birth : <input id="inputBirth" type="date" name="member_birth"><br>
		phone : <input id="inputPhone" type="text" name="member_phone"><br>
		e-mail : <input id="inputEmail" type="text" name="member_email"><br>
		<input type="button" value="회원가입" onclick="joinMemberSubmit1()">
	</form>
</body>
</html>
```





<br>
<br><br>


