---
title: "6주차 Java Study"
excerpt: "2021-11-29 ~ 2021-12-03"

toc: true
toc_sticky: true
categories:
  - Study
---
<br>
# API 2
---
## Wrapper(포장) 클래스
기본 타입의 값을 갖는 객체의 클래스, 외부에서 값을 변경할 수 없음<br><br>

박싱 : 기본타입 값 -> 포장객체
- 생성자의 매개값으로 기본타입 값 전달
- valueOf 사용(Character 제외하고 매개 값으로 문자열이 올 수 있음)

```java
Integer obj1 = new Integer(100);
Float obj2 = new Float("2.5F");
Character obj3 = Character.valueOf('가');
Double obj4 = Double.valueOf("3.5");
```

<br>
언박싱 : 포장객체 -> 기본타입의 값
- 기본타입명Value() 메소드 호출

```java
int var1 = obj1.intValue();
float var2 = obj2.floatValue();
char var3 = obj3.charValue();
double var4 = obj4.doubleValue();
```

<br>
자동박싱 : Wrapper 클래스타입에 기본 타입 값이 대입, 컬렉션 객체에 기본타입 값 저장
```java
Integer obj = 100;	// heap에 객체 생성, String과 달리 동일 값이라도 각자 다른 객체 생성됨
List<Integer> list = new ArrayList<Integer>();
list.add(200);	// Integer로 자동 박싱
```

<br>
자동언박싱 : 기본타입에 포장객체가 대입 or 포장객체와 기본타입을 연산할 경우
```java
int value1 = obj;
int value2 = obj + 100;
```
<br><br>
**문자열->기본타입 값으로 변환 :** `parse기본타입명()` 메소드 사용<br>
`ex) int num = Integer.parseInt("1000");`<br><br>

포장 값 비교 : ==와 !=는 객체의 번지비교 => 언박싱한 값 비교 또는 `equals()` 사용<br>
`cf) boolean 타입, char 0~127, byte/short/int -128~127 사이의 값은 ==, !=로 내부 값 바로 비교 가능`<br>
<br>

## 랜덤 값 얻기
1. Math.random() : 0.0 <= ~ < 1.0 사이의 double 타입 난수 리턴
2. Random 클래스 사용 : boolean, int, long, float, double 난수 리턴, seed 설정 가능

```java
Random random = new Random();
int randNum1 = ramdom.nextInt();	// -2^31 ~ 2^31-1 사이의 난수 리턴
int randNum2 = random.nextInt(10);	// 0 ~ (n-1) 사이의 난수 리턴, (int)(Math.random()*10); 와 동일
double randNum3 = random.nextDouble()	// 0.0 <= ~ <1.0 사이의 난수 리턴

Random randomSeed = new Random(5);	// seed 설정, seed가 같다면 동일 난수 리턴
```

<br><br>
<br>

# 제네릭(Generic)
---
클래스, 인터페이스, 메소드를 정의할 때 타입을 파라미터로 사용하게 해줌<br>
코드작성 시 구체적인 타입으로 대체 -> 다양한 코드, 코드 재사용률 ↑
<br><br>
<br>
제네릭의 이점
1. 컬렉션, 람다식, 스트림, NIO에서 유용
2. 컴파일시 강력한 타입체크
3. casting 제거

```java
//non-generic
List list1 = new ArrayList();
list1.add("hello");
String str1 = (String)list1.get(0);	// String으로 casting 발생

//generic
List<String> list2 = new ArrayList<String>();
list2.add("hello");
String str2 = list2.get(0);	// String으로 국한시켜 List를 생성 -> casting 불필요
```

<br><br>
## 제네릭 타입
타입을 파라미터로 가지는 클래스와 인터페이스<br>
실제 사용될 때 구체적인 타입을 지정 => 타입변환 최소화<br>
`public class 클래스명<T> {	...	}`<br>
`public interface 인터페이스명<T> {	...	}`<br>
<br>
<br>
* 타입 파라미터
  * <> 사이에 위치하며 보통 영문대문자 한 글자로 작성
  * 클래스타입만 들어갈 수 있음 => Object로 인식(null 대입 가능)
  * 기본 타입 값을 넣으면 포장 클래스로 자동 박싱

```java
public class Toy<T> {
	private T t;

	public T get() {	return t;	}
	public void set(T t) {	this.t = t;	}
}
```
```java
public class ToyEx {
	public static void main(String[] args) {
		Toy<String> toy = new Toy<String>();	// T => String 으로 대입
		//Toy<String> toy = new Toy<>();  빈 괄호<>로 해도 자동으로 String 인식

		toy.set("요요");
		String str = toy.get();
		System.out.println(str);	// 요요
	}
}
```

<br><br>
**멀티타입 파라미터 :** 콤마로 구분하여 두 개 이상의 타입 파라미터 사용 가능<br>
`public class Product<K, V> {	...	}`<br>
`Product<Key, Value> product = new Product<>();`
<br><br>
<br>

## 제네릭 메소드
매개타입과 리턴타입으로 타입 파라미터를 가지는 메소드<br>
리턴타입 앞에 타입 파라미터 기술 후 매개타입 또는 리턴타입으로 타입파라미터 사용
```java
public class Car<T> {
	private T t;
	
	Car(T t) {	this.t = t;	}
}
```
```java
public class CarEx {
	public static void main(String[] args) {
		// 구체적 타입 Integer로 명시
		Car<Integer> car1 = CarEx.<Integer>racing(10);
		// 매개값을 보고 타입 파라미터의 구체적인 타입 추정
		Car<Integer> car2 = racing(100);
	}

	public static <T> Car<T> racing(T t) {
		Car<T> car = new Car<>(t);
		return car;
	}
}
```

<br><br>
## 제한된 타입 파라미터
`<T extends 최상위타입>`<br>
* 구체적인 타입으로 부모 클래스, 상속받은 자식 클래스 또는 구현 클래스만 가능<br>
* 중괄호{ } 내에선 상위 타입의 멤버만 사용 가능<br>
* 인터페이스라도 implements가 아닌 extends 키워드 사용

```java
//T에는 Number의 하위타입인 Integer, Long, Float, Double 등만 대입 가능
public staic <T extends Number> double sum(T num1, T num2) {
	double d1 = num1.doubleValue();	// Number의 메소드인 doubleValue() 사용
	double d2 = num2.doubleValue();
	
	return d1 + d2;
}
```
```java
double result1 = sum(3.5, 5);
//double result2 = sum("안녕", "하세요");   String은 Number의 하위타입이 아니므로 에러 발생
```

<br><br>
💡**타입파라미터로 배열 생성 :** `T[] array = (T[]) (new Object[capacity]);`

<br><br>
## 와일드카드 타입
매개값이나 리턴타입으로 제네릭타입을 사용할 때 구체적인 타입 대신 와일드카드(?) 사용<br>
* **제네릭타입<?> :** 구체적 타입으로 모든 클래스나 인터페이스 타입 올 수 있음
* **제네릭타입<? extends 상위타입> :** 구체적 타입으로 상위타입~하위타입만 올 수 있음
  * 상위클래스 제한 => 상위의 상위 X
* **제네릭타입<? super 하위타입> :** 구체적 타입으로 하위타입~상위타입만 올 수 있음
  * 하위클래스 제한 => 하위의 하위 X

```java
class Beverage {	}
class Juice extends Beverage {	}
class SoftDrink extends Beverage {	}
class Coke extends SoftDrink {	}

class Drink<T> {	}
public class DrinkExample {
	static void method1(Drink<?> drink) {

	}
	static void method2(Drink<? extends SoftDrink> drink) {	// SoftDrink와 하위 클래스만 가능

	}
	static void method3(Drink<? super Juice> drink) {	// Juice와 상위 클래스만 가능

	}

	public static void main(String[] args) {
		Drink<Beverage> var1 = new Drink<>();
		Drink<Juice> var2 = new Drink<>();
		Drink<SoftDrink> var3 = new Drink<>();
		Drink<Coke> var4 = new Drink<>();

		method1(var1);
		method1(var2);
		method1(var3);
		method1(var4);

		//method2(var1);		// SoftDrink, Coke 만 가능
		//method2(var2);	
		method2(var3);
		method2(var4);

		method3(var1);
		method3(var2);
		//method3(var3);		// Beverage, Juice만 가능
		//method3(var4);
	}
}
```

<br><br>
## 제네릭타입의 상속과 구현
제네릭 타입도 부모클래스가 될 수 있음, 자식클래스에서 타입파라미터 추가 가능<br>
상속과 마찬가지로 인터페이스 구현클래스에 타입파라미터 추가 가능
```java
class Parent<T> {	}
class Child<T, M> extends Parent<T> {	}

interface Weather<T> {	}
class Rainy<T> implements Weather<T> {	}

public class GenericEx {
	public static void main(String[] args) {
		Child<String, Integer> child = new Child<>();
		Weather<Double> weather = new Rainy<>();
	}
}
```

<br><br>

# 람다식
---
익명함수를 생성하기 위한 식 => 런타임시 익명구현객체로 생성됨<br>
`인터페이스명 변수 = (매개값) -> { 실행문 };`<br><br>

* 인터페이스 변수에 대입됨
  * 어떤 인터페이스에 대입되느냐에 따라 구현될 인터페이스 결정
* 하나의 메소드만을 정의
  * 하나의 추상 메소드만 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있음(함수적 인터페이스)
  * `@FunctionalInterface` 어노테이션 : 인터페이스 선언시 기입하여 추상메소드가 한 개인지 체크

<br><br>
1.매개변수와 리턴값이 없는 람다식

```java
@FunctionalInterface
public interface MyInteface {
	public void method();
}
```
```java
MyInterface m = () -> {	System.out.println("매개변수와 리턴값이 없는 람다식");	};
m.method();	// 매개변수와 리턴값이 없는 람다식
```

<br>
2.매개변수가 있고 리턴값이 없는 람다식

```java
@FunctionalInterface
public interface MyInteface {
	public void method(int x);
}
```
```java
// 매개변수 타입은 런타임시 대입값에 따라 자동으로 인식 (int x) or (x) 모두 사용 가능
// 매개변수가 하나뿐이라면 괄호도 생략가능 x -> {	}
// 실행문도 하나뿐이라면 중괄호 생략가능 x -> ...
MyInterface m = x -> {	System.out.println("매개변수 " + x + "가 있고 리턴값이 없는 람다식");	};
m.method();	// 매개변수 n가 있고 리턴값이 없는 람다식
```

<br>
3.매개변수와 리턴값이 있는 람다식

```java
@FunctionalInterface
public interface MyInterface {
	public int method(char a, char b);
}
```
```java
// 중괄호에 연산식이나 메소드 호출하는 return문만 있다면 중괄호와 return 생략가능
// (a,b) -> a+b; or (a,b) -> sum(a, b);
MyInterface m = (a, b)-> a + b;
int result = m.method('a', 'b');	// 매개변수와 리턴값이 있는 람다식
```

<br><br>
* 람다식에서 클래스의 멤버 사용
  * 제약없이 사용 가능
* 람다식에서 로컬 변수 사용
  * 로컬익명구현객체와 마찬가지로 람다식에서 사용되는 메소드의 매개변수/로컬변수는 final 특성을 가짐
  * 람다식에서의 this는 람다식을 실행한 객체를 참조함

```java
interface MyInterface {
	public void method();
}
```
```java
public class Outter {
	int outterField = 1;

	class Inner {
		int innerField = 10;

		void method(int a) {
			int b = 1;
			MyInterface m = () -> {
				// Inner의 필드
				System.out.println(this.innerField);
				// Outter 참조위해 클래스명.this 사용
				System.out.println(Outter.this.outterField);

				innerField = 20;	// 클래스 멤버는 값 변경 가능
				// 매개변수와 로컬변수는 final 특성을 가져 수정 불가
				//a = 2;
				//b = 3;
			};
			m.method();
		}
	}
}
```

<br><br>
<br>
# 컬렉션 프레임워크(Collection FrameWork)
---
> 배열의 문제점<br>
>> 배열을 생성할 때 크기를 지정해야함<br>
>> 크기를 변경하고 싶을 경우 새로운 배열을 생성한 뒤 복사하는 작업 필요<br>
>> 배열 원소 삭제하고 싶을 땐 해당 원소값을 null로 초기화 => 참조를 잃어 구멍난 것 처럼 보임<br>
>> 빈 곳을 채우려면 항목을 탐색해서 위치 찾아야함<br>

<br>
<br>
**컬렉션 :** 요소(객체)를 수집해 저장하는 것<br>
**컬렉션 프레임워크 :** 컬렉션과 저장된 클래스, 인터페이스들<br>
<br>
* 배열의 문제점을 해결하는 것에 주안점을 둠
  * 크기 가변적 변경 가능
  * 삭제하더라도 중간에 구멍 안 남
  * 원소 추가 / 삭제 / 변경 / 조회 가능
* 원소는 class type만 올 수 있음
  * primitive type은 wrapper class로 boxing하여 사용
<br><br>

|인터페이스 분류|	|특징|구현클래스|
|:--------:|:--------------:|:------------------------:|
|**Collection**	|**List**|순서를 유지하고 저장, 중복저장 가능|ArrayList, Vector, LinkedList|
|**Collection**	|**Set**|순서를 유지하지 않고 저장, 중복저장 불가|HashSet, TreeSet|
|**Map**|	|키와 값의 쌍으로 저장, 키는 중복저장 안됨|HashMap, Hashtable, TreeMap, Properties|


<br><br>
## List
객체를 일렬로 늘어놓은 구조
* 원소를 저장하면 자동으로 인덱스 부여
  * 인덱스로 객체를 관리, 원소는 객체의 번지를 참조
* 동일한 객체 중복 저장(동일한 번지 참조)
* null 저장 가능(참조하는 객체 없음)

<br>

### ArrayList
---
* 인덱스 0부터 차례대로 저장, 초기용량 10
  * 생성자 매개변수로 capacity 줄 수 있음
* 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 한 칸씩 당겨짐, 삽입하면 한 칸씩 밀려남<br>
=> 객체 추가/삭제가 빈번한 경우 LinkedList에 비해 성능 안 좋음<br>
=> 끝에서부터 객체 추가/삭제, 인덱스 검색은 ArrayList가 빠름<br><br>

```java
List<String> list = new ArrayList<>();

list.add("고양이");		// 리스트 끝에 추가
list.add("강아지");
list.add("호랑이");
list.add(2, "늑대");		// 지정한 인덱스에 추가(뒤의 객체들 한 칸씩 밀려남)
list.add("망아지");
		
list.set(4, "포니");		// 지정한 인덱스의 객체와 대치
	
list.remove("늑대");		// 해당 객체 삭제
list.remove(1);			// 지정한 인덱스의 객체 삭제
		
for(int i=0;i<list.size();i++) {
	System.out.println(list.get(i));	// 지정한 인덱스의 객체 가져옴
}
		
		
for(String s : list) {		// 향상된 for문 사용 가능
	System.out.println(s);	// 고양이, 호랑이, 포니
}
```

<br><br>
cf)런타임시 추가하는 것이 아닌 고정된 객체들로 구성된 List 생성<br>
`List<T> list = Arrays.asList(T... a);`<br>
<br>
<br>

### Vector
---
* ArrayList와 동일한 내부 구조, 초기용량 10
  * 생성자 매개변수로 capacity 줄 수 있음
* 멀티스레드가 동시에 실행 X
  * 하나의 스레드가 실행을 완료해야만 다른 스레드 실행
  * 멀티스레드 환경에서 안전하게 객체 추가, 삭제 가능(Thread Safe)

<br><br>

### LinkedList
---
* ArrayList와 내부구조가 완전 다름, 초기엔 빈 상태
* 인접 참조를 링크하여 체인처럼 관리
* 특정 객체에 변화(추가, 삭제)가 생기면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않음
  * 빈번한 중간 객체의 추가/삭제가 있다면 LinkedList가 성능이 좋음

<br><br>

## Set
수학의 집합과 같은 구조
<br><br>
* 중복 값 허용되지 않음, 하나의 null만 저장가능
* 저장 순서가 상관없음(인덱스로 관리되지 않음)
  * get() 메소드 없음, add(), remove(), size() 등은 있음
  * 반복자(Iterator) 또는 향상된 for문을 통해 원소에 접근

```java
Set<String> set = ...;

Iterator<String> iterator = set.iterator();
iterator.hasNext();		// 가져올 객체가 있으면 true 아니면 false
iterator.next();		// 컬렉션에서 객체 하나를 가져옴
iterator.remove();		// Set 컬렉션에서 객체를 제거(실제 Set에서 삭제됨)
```
```java
Set<String> set = new HashSet<>();
set.add("고양이");
set.add("강아지");
set.add("호랑이");
//set.add(2, "늑대");		인덱스 없어 사용 불가
set.add("망아지");
set.add("망아지");		// "망아지"는 한 번만 저장됨
//set.set(4, "포니");		인덱스 없어 사용 불가
		
set.remove("늑대");
//set.remove(3);		삭제되지 않음
		
Iterator<String> iterator = set.iterator();
while(iterator.hasNext()) {
	System.out.println(iterator.next());	// 호랑이, 고양이, 망아지, 강아지
}
		
iterator.remove();			// Set의 강아지 삭제
		
for(String s : set) {
	System.out.println(s);		// 호랑이, 고양이, 망아지
}
```


<br><br>
### HashSet
---
Set의 구현 클래스로 중복저장하지 않음<br>
=> 꼭 같은 인스턴스를 뜻하진 않음(hashCode(), equals() override에 따라)
<br><br>

1. 객체 저장 전 먼저 객체의 hashCode() 메소드 호출
2. 이미 저장된 객체들의 해시코드와 비교 => false가 나오면 저장
3. 만약 동일한 해시코드가 존재한다면 equals() 메소드를 호출하여 두 객체를 비교
4. true가 나오면 중복으로 판단하여 저장 X <=> false가 나오면 저장


<br><br>
*Hash Function*<br>
* 입력데이터를 받아 hash code값을 return하는 함수
* 어떠한 크기의 입력 데이터라도 "정해진 크기의 값"으로 변환하는 함수
* 개인정보 등 데이터를 암호화하는 기법 중의 하나
* Java가 힙메모리의 객체 주소를 hash함수를 사용하여 hash code로 변환하여 표현함
* 여러 객체의 여러 주소가 하나의 hash code 값으로 변환될 수 있음(1 : m 관계)
  * 동등한지 비교할 때 (1)hashCode() 결과 비교 --같음--> (2)equals()로 비교 --같음--> 같은 객체

```java
// hashCode()와 equals()를 재정의하여 name, age의 값이 같다면 동일 객체로 인식됨
public class Member {
	String name;
	int age;
	
	public Member(String name, int age) {
		this.name = name;
		this.age = age;
	}

	@Override
	int hashCode() {
		return name.hashCode() + age;
	}

	@Override
	boolean equals(Obejct obj) {
		if(obj instanceof Member) {
			Member member = (Member) obj;
			return (name.equals(member.name)) && (age == obj.age);
		} else return false;
	}
}
```


<br><br><br>
<br>
**Collections class의 메소드**<br>
<br>
`Collections.max(Collection 구현객체)` : 원소의 최대값<br>
`Collections.min(Collection 구현객체)` : 원소의 최소값<br>
`Collections.binarySearch(List 구현객체, 찾을값)` : 찾는 값의 인덱스 return, 먼저 sort() 후 사용<br>
`Collections.disjoint(Collections 구현객체1, Collections 구현객체2)` : 동일한 원소가 없으면 true, 있으면 false<br>
`Collections.copy(List 구현객체dest, List 구현객체src)` : src 원소를 dest에 덮어씌움<br>
`Collections.sort(List 구현객체)` : 원소 오름차순정렬<br>
`Collections.reverse(List 구현객체)` : 원소 순서를 reverse <br>
> 내림차순 정렬 : `sort()` 후 `reverse()`<br>

<br>
<br>

## Map
key과 value로 구성된 Entry 객체를 저장하는 구조(Entry = key와 value 한 쌍)<br>
키와 값은 모두 객체이며 키는 중복저장X, 값은 중복저장 가능<br>
기존에 있는 키와 동일한 키로 값을 저장하면 값이 새로운 값으로 대체됨<br>
<br>

* `put(key, value)` : 객체추가, `get(key)` : 객체얻기, `remove(key)` : 객체 삭제
* `Set<K> set = map.keySet();` 전체 키 얻기
* `Set<Map.Entry<K, V>> entrySet = map.entrySet();` 전체 Entry 얻기
  * Map.Entry : `getKey(); getValue();` 메소드가 있어 키와 값 얻을 수 있음
* `map.forEach(BiConsumer<? super K, ? super V> action);` : Map 인터페이스의 default 메소드
  * `entrySet()` 호출하여 key, value get => `action.accpet(key, value);` 호출하여 람다식의 실행문 실행
  * `map.forEach((key, value)-> System.out.println(key + ", " + value));`

<br><br>

### HashMap
---
키로 사용할 객체는 `hashCode() [-> equals()]` 메소드를 이용해 동일한 키가 있는지 체크
<br>
```java
public class MenuEx {
	public static void main(String[] args) {
		Map<String, Integer> menu = new HashMap<>();
		
		menu.put("불고기버거", 5000);
		menu.put("포테이토피자", 17000);
		menu.put("파인트아이스크림", 6700);
		menu.put("반반순살치킨", 19000);
		menu.put("젤리", 2000);
		menu.put("천연사이다",1500);
		menu.put("모닝토스트", 2000);
		
		System.out.println("[전체 메뉴]");
		menu.forEach((key, value) -> System.out.println("상품: " + key + ", 가격: " + value + "원"));
				
		System.out.print("\n불고기버거 주문 -> ");
		System.out.println(menu.get("불고기버거") + "원 입니다.");		// 5000원 입니다.
	}
}
```

<br><br>
**Hashtable :** HashMap과 동일한 내부구조이지만 동기화된 메소드(synchronized method)로 구성되어있음(thread safe)
<br>
<br><br>

### Properties
---
Hashtable의 하위 클래스로 대부분 비슷한 특징을 갖고 있지만 Properties는 키와 값을 String 타입으로만 제한<br>
.properties 파일 읽을 때 주로 사용
<br><br>
<br>
*프로퍼티 파일은 키와 값이 = 기호로 연결되어 있는 텍스트파일(ISO 8859-1문자셋 사용, 한글은 유니코드로 변환)*<br>

<br>
> 프로퍼티파일 용도
>> 프로그램 외부에서 프로그램 내부에 필요한 환경설정 정보를 관리할 목적<br>
>> driver=oracle.jdbc.OracleDriver 여기서 Oracle을 MySQL 등 다른 DBMS로 변경해야할 경우<br>
>> 프로퍼티 파일 내 환경설정 정보만 변경하고 실제 소스코드는 수정하지 않아도 됨<br>
>> (변경이 잦은 문자열을 저장하여 유지보수를 편리하게 해줌)<br>


<br><br>
`database.properties`
```java
driver=oracle.jdbc.OracleDriver
url=jdbc:oracle:thin:@localhost:1521:orcl
username=scott
password=tiger
```
```java
Properties properties = new Properties();
// 프로퍼티 파일은 일반적으로 클래스파일(.class)과 함께 저장 => 클래스 파일을 기준으로 상대경로를 이용해 파일 경로 얻기
// getResource() : 주어진 파일의 상대경로를 URL 객체로 리턴 => getPath() : 파일의 절대 경로를 리턴
String path = PropertiesEx.class.getResource("database.properties").getPath();
path = URLDecoder.decode(path, "utf-8");	// 경로에 한글이 있을 경우 디코딩하여 한글로 복원
properties.load(new FileReader(path));

// 프로퍼티 파일에서 읽은 값 가져오기
String driver = properties.getProperty("driver");	 // oracle.jdbc.OracleDriver
// get()은 Object로 리턴하여 캐스팅 필요
String url = (String) properties.get("url");
```

<br><br>
<br>
## LIFO와 FIFO컬렉션
<br>
**Stack 클래스**<br><br>
LIFO(Last In First Out) 자료구조를 구현<br>
`push()` : 넣기<br>
`pop()` : 맨 위 객체 꺼내고 지우기<br>
`peek()` : 맨 위 객체 꺼내기(지우진않음)
```java
Stack<E> stack = new Stack<E>();
stack.push(e);
stack.pop();		// 향상된 for문 쓰면 FIFO로 꺼내짐
stack.peek();
boolean result = stack.isEmpty();	// 스택이 비었는지 확인
```

<br><br>
**Queue 인터페이스**<br><br>
FIFO(First In First Out) 자료구조를 구현<br>
`offer()` : 넣기<br>
`poll()` : 맨 앞 객체 꺼내고 지우기<br>
`peek()` : 맨 앞 객체 꺼내기(지우진 않음)<br>
Queue의 가장 대표적인 구현클래스는 LinkedList
```java
Queue<E> queue = new LinkedList<E>();
queue.offer(e);
queue.poll();
queue.peek();
boolean result = queue.isEmpty();	// 큐가 비었는지 확인
```

<br><br>
<br>

# IO 패키지
---
자바의 기본적인 입출력 API 제공
<br><br>
<br>
**stream :** 자바에서 데이터는 스트림을 통해 입출력됨, stream은 단방향성<br>
- 입력스트림(input stream) : 외부에서 프로그램이 데이터를 입력받음
  * 출발지는 키보드, 파일, 네트워크상 프로그램 등
- 출력스트림(output stream) : 프로그램에서 데이터를 외부에 출력
  * 도착지는 모니터, 파일, 네트워크상 프로그램 등
<br><br>

<center><img src="https://user-images.githubusercontent.com/57750308/144696277-5e26d98d-54f4-4e28-a598-b975e5a9be94.png"></center>

`=>스트림은 단방향성이므로 통신하는 양쪽 프로그램 모두 입력스트림과 출력스트림이 따로 필요함`<br>
`(ex. web programming => web browser - web server)`<br>



<br><br>
## InputStream
바이트기반 입력 스트림의 최상위 클래스(추상클래스)<br><br>

그림, 멀티미디어, 문자 등 모든 종류의 데이터 읽을 수 있음<br>
자식클래스 : `FileInputStream, BufferedInputStream, DataInputStream`<br>

<br>
**read()**<br>
* 입력스트림으로부터 1바이트를 읽고 읽은 바이트를 int(4byte)로 리턴
* 리턴된 4byte 중 끝의 1byte에만 데이터가 들어있음
  * 더이상 읽을 데이터가 없으면 -1 리턴

```java
// 이클립스 기본경로는 자바프로젝트가 생성된 폴더
InputStream is = new FileInputStream("src/p01/io/inputstream/test.txt");
int readByte;
while((readByte = is.read()) != -1) {
	System.out.println((char)readByte);	// ASCII 코드값이라 char로 캐스팅
}
```

<br>
**read(byte[] b)**<br>
* 입력스트림으로부터 매개값 바이트 배열의 길이만큼 바이트를 읽고 배열에 저장 후 읽은 바이트 수를 리턴
* 읽은 바이트 수가 배열길이보다 작더라도 실제 읽은 바이트 수만큼만 리턴
  * 더이상 읽을 데이터가 없으면 -1 리턴
* 많은 양의 바이트를 읽을 때 좋음(read()는 한글(2byte) 못 읽음)

```java
InputStream is = new FileInputStream("src/p01/io/inputstream/test.txt");
int readByteNo;
byte[] readByte = new byte[5];	// 한 번에 바이트 5개씩 읽음
String data = "";

while((readByteNo = is.read(readByte)) != -1) {
	data += new String(readByte, 0, readByteNo);
}
System.out.println(data);
```

<br>
**read(byte[] b, int offset, int len)**<br>
* 입력스트림으로부터 len 개의 바이트를 읽어 b[offset]부터 len개까지 저장 후 읽은 바이트 수를 리턴
  * 더이상 읽을 데이터가 없으면 -1 리턴
<br><br>

**close() :** InputStream을 더이상 사용하지 않을 경우 호출하여 시스템 자원을 풀어줌
<br>
<br><br>

## OutputStream
바이트기반 출력 스트림의 최상위 클래스(추상클래스)<br><br>

그림, 멀티미디어, 문자 등 모든 종류의 데이터 쓸 수 있음<br>
자식클래스 : `FileOutputStream, BufferedOutputStream, DataOutputStream, printStream`<br>

<br>
**write(int b)**<br>
매개변수로 주어진 int 값에서 끝에 있는 1바이트만 출력스트림으로 보냄

```java
// 디렉토리는 생성되지 않음, 기존 파일은 새로운 파일로 덮어씌워짐
OutputStream os = new FileOutputStream("src/p02/io/outputstream/test.txt");
byte[] data = "ABC".getBytes();

for(int i=0;i<data.length;i++) {
	os.write(data[i]);	// byte->int 자동형변환, 출력버퍼에 바이트단위로 write
}
os.flush();		// 출력 버퍼에 있는 문자들 전체를 한번에 file에 write
os.close();
```

<br>
**write(byte[] b)**<br>
매개값으로 주어진 바이트 배열의 모든 바이트를 출력 스트림으로 보냄

```java
OutputStream os = new FileOutputStream("src/p02/io/outputstream/test.txt");
byte[] data = "ABCDE".getBytes();

os.write(data);	// "ABCDE" 모두 출력
```

<br>
**write(byte[] b, int offset, int len) :** b[offset]부터 len개의 바이트를 출력 스트림으로 보냄
<br><br>

**buffer**<br>
* 출력스트림은 내부에 작은 buffer가 있어 데이터가 출력 전 버퍼에 쌓여있다가 순서대로 출력됨
* flush()
  * 버퍼에 잔류하고 있는 데이터를 모두 출력시키고 버퍼를 비움
* close()
  * OutputStream을 더이상 사용하지 않을 경우 호출하여 시스템 자원 풀어줌

<br>
<br><br>

## Reader
문자 기반 입력 스트림의 최상위 클래스(추상클래스)<br><br>

문자 단위로만 데이터 읽기 가능(텍스트 파일만 가능)<br>
자식클래스 : `FileReader, BufferedReader, InputStreamReader`<br>

<br>
**read()**<br>
* 한 개의 문자(2byte)를 읽고 int(4byte)타입으로 리턴
* 리턴된 4byte 중 끝의 2byte에만 문자 데이터 들어있음
  * 더이상 입력스트림으로부터 문자를 읽을 수 없다면 -1 리턴

```java
Reader reader = new FileReader("src/p02/io/outputstream/test.txt");
int readData;
while((readData = reader.read()) != -1) {
	System.out.println((char)readData);
}
```

<br>
**read(char[] cbuf)**<br>
* 매개값으로 주어진 문자 배열의 길이만큼 문자를 읽고 배열에 저장 후 읽은 문자 수 리턴
  * 더이상 읽을 데이터가 없다면 -1 리턴
* 한 번에 주어진 배열 길이만큼 읽기 때문에 많은 양의 문자를 읽을 때 좋음

<br><br>
**read(char[] cbuf, int offset, int len)**<br>
* len개의 문자만큼 읽어 cbuf[offset] 부터 len개 까지 저장 후 읽은 문자 수 리턴
  * 더이상 입력스트림으로부터 문자를 읽을 수 없다면 -1 리턴

<br><br>
**close() :** Reader를 더이상 사용하지 않을 경우 호출하여 시스템 자원을 풀어줌

<br><br>

## Writer
문자 기반 출력 스트림의 최상위 클래스(추상클래스)<br><br>

문자 단위로만 데이터 쓰기 가능(텍스트 파일만 가능)<br>
자식클래스 : `FileWriter, BufferedWriter, OutputStreamReader, PrintWriter`<br>

<br>
**write(int c)**<br>
매개 변수로 주어진 int 값에서 끝에 있는 2바이트(한 개의 문자)만 출력 스트림으로 보냄

```java
Writer writer = new FileWriter("src/p04/io/writer/test.txt");
char[] data = "안녕하세요".toCharArray();
for(int i=0;i<data.length;i++) {
	writer.write(data[i]);	// "안", "녕", "하", "세", "요" 를 하나씩 출력
}
```

<br>
**write(char[] cbuf)**<br>
매개값으로 주어진 char[] 배열의 모든 문자를 출력 스트림으로 보냄

```java
Writer writer = new FileWriter("src/p04/io/writer/test.txt");
char[] data = "안녕하세요".toCharArray();
writer.write(data);	// "안녕하세요" 모두 출력
```

<br>
**write[char[] cbuf, int offset, int len)**<br>
len개의 문자를 읽어 c[off]부터 len개의 문자를 출력스트림으로 보냄

<br><br>
**buffer**<br>
* 문자 출력스트림은 내부에 작은 buffer가 있어 데이터가 출력 전 버퍼에 쌓여있다가 순서대로 출력됨
* flush()
  * 버퍼에 잔류하고 있는 데이터를 모두 출력시키고 버퍼를 비움
* close()
  * Writer를 더이상 사용하지 않을 경우 호출하여 시스템 자원 풀어줌

<br>
<br><br>

## 콘솔입출력

콘솔 : 키보드로 입력받고 화면으로 출력하는 sw. 터미널, cmd 등<br>
<br>

**System.in**<br>
* 자바에서 콘솔로부터 데이터 입력받을 때
* System의 InputStream 타입 정적 필드
  * 바이트 단위로 읽음
  * InputStream 메소드 사용 가능

```java
InputStream is = System.in;

char a = (char) is.read();	// 1byte 단위의 데이터를 읽음(2byte 한글 못 읽음)

byte[] datas = new byte[100];
int readByteNo = is.read(datas);
// readByteNo-2 : 엔터로 인한 캐리지 리턴과 라인피드 제외
String str = new String(datas, 0, readByteNo-2);
```
<br>

**System.out**<br>
* 자바에서 콘솔에 데이터 출력할 때
* System의 PrintStream(OutputStream의 하위클래스) 타입 정적 필드
  * 바이트 단위로 출력
  * PrintStream, OutputStream 메소드 사용 가능

```java
OutputStream os = System.out;
byte a = 97;
os.write(a);	// a : 1byte 아스키 코드를 문자로 콘솔에 출력(2byte 한글 출력X)
os.flush();
```
`PrintStream 타입의 필드이므로 print(), println() 메소드를 사용하면 좀 더 쉽게 콘솔 출력 가능`

<br>
<br>
**System.err 필드 :** 개발자가 에러를 콘솔에 출력할 때 사용
<br><br>
<br>

**Console 클래스**<br>
Console 객체는 System의 정적메소드인 console()을 호출하여 얻을 수 있음
```java
Console console = System.console();	// 이클립스에서 System.console() 메소드는 null리턴 -> cmd에서 실행해야함
String id = console.readLine();	// 엔터 입력전 모든 문자열 읽기
char[] charPass = console.readPassword(); // 입력 문자를 에코 출력하지 않고 문자열 읽음
```

<br>
<br><br>
## File 클래스
파일 시스템의 파일을 표현하는 클래스<br>

* 파일 생성/삭제/정보, 디렉토리 생성, 파일리스트 얻는 것도 가능
* 파일의 데이터를 읽고 쓰는 것은 지원하지 않음(입출력 스트림 사용해야함)

```java
// 객체생성(객체를 생성했다고 파일이나 디렉토리가 생기는건 아님)
File dir = new File("src/p06/FileManage/dir");
File textFile = new File("src/p06/FileManage/text.txt");

// 실제 존재여부 확인
boolean isExist = dir.exists();

//생성
dir.mkdir();
textFile.createNewFile();

// 파일경로를 URI 객체로 생성해서 매개값으로 제공
File textFile2 = new File(new URI("file:///c:/DevSpace/JavaSpace/Ch18_FileIO/src/p06/FileManage/text2.txt"));
```
`URI scheme(URI 표기법) : Uniform Resource Identifier, 모든자원을 표현하는 통일된규칙`<br>
`http://~~~ 다른 장소(웹)에 있는 것을 표현할 때`<br>
`file://~~~~ 로컬에 있는 것을 표현할 때`<br>

<br><br>
**File Method**<br>
* `getPath()` : 전체 경로 리턴
* `getName()` : 파일명 리턴
* `isDirectory()`, `isFile()` : 디렉토리, 파일 여부 확인
* `lastModified()` : 마지막 수정날짜 리턴
* `length()` : 파일 크기 리턴
* `list()` : 디렉토리에 포함된 파일 및 서브 디렉토리 목록 전부를 String[] 로 리턴
* `listFiles()` : 디렉토리에 포함된 파일 및 서브 디렉토리 목록 전부를 File[] 로 리턴

<br>
<br>
### FileInputStream
---
파일로부터 바이트 단위로 데이터를 읽음
<br>
* 모든 종류 파일 읽을 수 있음
* 객체 생성
  * `FileInputStream fis = new FileInputStream("파일경로");`
  * `File file = new File("파일경로");`<br>
`FileInputStream fis = new FileInputStream(file);`
* new File과 달리 객체 생성될 때 파일과 직접 연결됨
  * 존재하지 않는 파일은 `FileNontFoundException` 발생
* InputStream의 하위 클래스로 동일 메소드 사용
  * `read()`로 읽고 -1리턴하면 다 읽은 것 => `close()`로 자원 닫기

<br><br>

### FileOutputStream
---
바이트 단위의 데이터를 파일에 저장
<br>
* 모든 종류 데이터 파일로 저장할 수 있음
* 객체 생성
  * `FileOutputStream fos = new FileOutputStream ("파일경로");`
  * `File file = new File("파일경로");`<br>
`FileOutputStream fos = new FileOutputStream(file);`
* 이미 파일이 존재한다면 새로운 파일로 덮어씀
  * 기존 파일 내용 끝에 데이터를 추가할 경우 생성자의 두 번째 매개값으로 true
    * `FileOutputStream fos = new FileOutputStream ("파일경로", true);`
* OutputStream의 하위 클래스로 동일 메소드 사용
  * `write()`로 버퍼에 넣음 => `flush()`로 버퍼에 잔류 하는 데이터 완전 출력 => `close()`로 자원 닫기

<br><br>
🎈**이미지파일 복사**
```java
String originalFileName = "c:/desertfox.jpg";
String targetFileName = "src/p07/file_practice/copied_desertfox.jpg";
		
FileInputStream fis = new FileInputStream(originalFileName);
FileOutputStream fos = new FileOutputStream(targetFileName);
		
int readByteNo;
byte[] readBytes = new byte[100];
while((readByteNo = fis.read(readBytes)) != -1) {
	fos.write(readBytes, 0, readByteNo);	// 읽은 바이트를 바로 타겟 파일로 저장(복사프로그램 원리)
}

fos.flush();	// 관행적으로 나중에 연 것을 먼저 닫음
fos.close();
fis.close();
```

<br><br>
### FileReader
---
문자 단위로 텍스트 파일을 읽을 때 사용하는 문자기반 스트림
<br>
* 텍스트만 읽을 수 있음
* 객체 생성
  * `FileReader fr = new FileReader("파일경로");`
  * `File file = new File("파일경로");`<br>
`FileReader fr = new FileReader(file);`
* 객체가 생성될 때 파일과 직접 연결됨
  * 파일이 존재하지 않는 경우 `FileNotFoundException` 발생
* Reader의 하위클래스로 동일 메소드 사용
  * `read()`로 읽고 -1리턴하면 다 읽은 것 => `close()`로 자원 닫기

<br><br>

### FileWriter 
---
문자 단위로 텍스트 데이터를 파일에 저장할 때 사용하는 문자기반 스트림
<br>
* 텍스트만 저장할 수 있음
* 객체 생성
  * `FileWriter fw = new FileWriter("파일경로");`<br>
  * `File file = new File("파일경로");`<br>
`FileWriter fw = new FileWriter(file);`
* 지정된 파일이 이미 존재할 경우 덮어씀
  * 기존 파일 내용 끝에 데이터를 추가하려면 생성자의 두 번째 매개값으로 true 전달
  * `FileWriter fw = new FileWriter("파일경로", true);`
* Writer의 하위클래스로 동일 메소드 사용
  * `write()`로 버퍼에 넣음 => `flush()`로 버퍼에 잔류 하는 데이터 완전 출력 => `close()`로 자원 닫기
* `write(String str)`로 문자열 저장가능

```java
FileWriter fw = new FileWriter("text.txt");
fw.write("안녕하세요.\r\n");
fw.write("안녕히가세요.\r\n");
fw.flush();
fw.close();
```

<br><br>
<br>
## 보조스트림
다른 스트림과 연결되어 편리한 기능 제공(필터스트림이라고도 함)
<br><br>
자체적으로 입출력 수행 X => 다른 스트림에 연결하여 입출력 수행<br>
문자변환, 입출력 성능향상, 기본데이터 타입 입출력, 객체 입출력 등 기능 제공
<br>

<center><img src="https://user-images.githubusercontent.com/57750308/144697890-5a6115ac-6cce-49f3-b01b-4379f9a5f8ab.png"></center>

<br><br>

👇👇*보조스트림에 또 다른 보조스트림 연결하여 **스트림체인** 구성 가능*

<center><img src="https://user-images.githubusercontent.com/57750308/144697910-47b8cdc2-871a-47f0-b403-a6cfbc3bc7b0.png"></center>

<br>
<br>
보조스트림 생성<br>
`보조스트림 변수 = new 보조스트림(연결스트림);`<br><br>
<br>
### 문자변환 보조스트림
---
**InputStreamReader(inputStream is)**<br>
* InputStream을 parameter로 받아서 byte 단위로 읽은 입력 데이터를 char 단위로 변환하는 class
* 바이트 입력 스트림에 연결되어 문자입력스트림인 Reader로 변환시키는 보조스트림
  * `바이트 -> InputStream -> Reader(InputStreamReader) --문자--> 프로그램`

```java
InputStream is = System.in;
Reader reader = new InputStreamReader(is);
```

<br>
**OutputStreamWriter(OutputStream os)**<br>
* 바이트 출력 스트림에 연결되어 문자입력스트림인 Writer로 변환시키는 보조스트림
  * 프로그램 --문자--> Writer(OutputStreamWriter) -> OutputStream -> 바이트

```java
FileOutputStream fos = new FileOutputStream("text.txt");
Writer writer = new OutputStreamWriter(fos);

String data = "문자열입니다";
writer.write(data);

writer.flush();
writer.close();
```

<br>
<br><br>
### 성능향상 보조스트림
---
* 프로그램 실행성능은 입출력이 가장 느린 장치를 따라감
* 프로그램이 입출력 소스와 직접 작업하지 않고 중간에 메모리 버퍼와 작업함으로 실행 성능 향상
  * 프로그램 ---데이터---> 메모리버퍼 ---한번에 버퍼내용 모두를 전송---> 하드디스크
* 버퍼는 데이터가 쌓이기를 기다렸다가 꽉 차게되면 데이터를 한 꺼번에 하드로 보냄(출력횟수 줄어듬)

<br><br>
**BufferedInputStream, BufferedReader**<br>
* 바이트/문자 입력 스트림에 연결되어 버퍼를 제공해주는 보조 스트림
* 입력스트림으로부터 자신의 내부 버퍼 크기(최대 8192 바이트/8192 문자)만큼 데이터를 미리 읽고 버퍼에 저장
* BufferedReader는 `readLine()`메소드를 추가적으로 가짐
  * `\r\n` 으로 구분된 행 단위의 문자열 한꺼번에 읽음

```java
BufferedInputStream bis = new BufferedInputStream(바이트입력스트림);
BufferedReader br = new BufferedReader(문자입력스트림);
```

<br>
**BufferedOutputStream, BufferedWriter**<br>
* 바이트/문자 출력 스트림에 연결되어 버퍼를 제공해주는 보조 스트림
* 전송받은 데이터를 내부 버퍼(최대 8192바이트/8192 문자)에 쌓아두었다가 꽉차면 한꺼번에 목적지로 보냄
* 버퍼가 가득 찼을 때만 출력 => 마지막 자투리 데이터가 버퍼에 남아있을 수 있음
  * 종료 전 `flush()` 호출하여 버퍼에 잔류하고 있는 데이터 전부 내보내야함

```java
BufferedOutputStream bos = new BufferedOutputStream(바이트출력스트림);
BufferedWriter bw = new BufferedWriter(문자출력스트림);
```

<br><br>
<br>



# 실습문제
---
**List 연습**<br>
`ArrayList, LinkedList, Queue 기본 문법 실습`
```java
import java.util.*;

public class Test_ArrayList {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		
		list.add("복숭아");		// 0
		list.add("포도");		// 1
		list.add("참외");		// 2
		list.add("사과");		// 3
		list.add("바나나");		// 4
		list.add("키위");		// 5
		list.add("포도");		// 6	List는 중복허용
		list.add("포도");		// 7
		
		System.out.println("요소갯수 : " + list.size());
		
		Iterator<String> iter = list.iterator();
		
		while(iter.hasNext()) {	// 데이터가 존재하는한 반복수행
			System.out.println(iter.next());	// 요소를 얻어내어 출력
		}// while
		
		System.out.println();
	}
}
```
```java
import java.util.*;

public class LinkedListTest {
	public static void main(String[] args) {
		//LinkedList => LinkedList<T>
		List<Character> lList = new LinkedList<>();
		
		lList.add(new Character('a'));
		lList.add(new Character('b'));
		lList.add(new Character('c'));
		
		for(int i=0;i<lList.size();i++) {
			System.out.print(lList.get(i) + "\t");
		}
		
		System.out.println();
		
		// 반복자를 통한 출력
		Iterator<Character> iter = lList.iterator();
		while(iter.hasNext()) {
			System.out.print(iter.next() + "\t");
		}
	}
}
```
```java
import java.util.*;

public class QueueTest {
	public static void main(String[] args) {
		// 큐가 인터페이스이므로, 구현은 linkedlist로
		Queue<String> queue = new LinkedList<>();
		
		queue.add("JAVA");
		queue.add("SCRIPT");
		queue.add("JSP");
		while(!queue.isEmpty()) {
			System.out.println(queue.remove());
		}
	}
}
```
<br>
**합집합 만들기**<br>
`정수 5개를 원소로 갖는 두 ArrayList의 합집합을 만드시오.`
```java
import java.util.*;

public class Question02 {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		
		List<Integer> list1 = new ArrayList<>();
		List<Integer> list2 = new ArrayList<>();
		
		System.out.println("list1의 원소 정수 5개를 입력하시오.");
		for(int i=0;i<5;i++) {
			list1.add(input.nextInt());
		}

		System.out.println("list2의 원소 정수 5개를 입력하시오.");
		for(int i=0;i<5;i++) {
			list2.add(input.nextInt());
		}
		
		List<Integer> unionSet = union(list1, list2);
		
		for(Integer i : unionSet) {
			System.out.print(i + " ");
		}
		
		input.close();
	}
	
	public static List<Integer> union(List<Integer> list1, List<Integer> list2) {	
		list1.addAll(list2);
		Set<Integer> unionSet = new HashSet<>(list1);

		return new ArrayList<>(unionSet);
	}
}
```
<br>
**List 중복제거**<br>
`10개의 정수를 원소로 갖는 ArrayList를 만들고 중복된 원소를 제거하시오.`
```java
import java.util.*;

public class Question03 {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in); 
		
		List<Integer> list = new ArrayList<>();
		
		System.out.println("list의 원소 정수 10개를 입력하시오.");
		for(int i=0;i<10;i++) {
			list.add(input.nextInt());
		}
		
		removeDuplicate(list);
		
		input.close();
	}

	public static void removeDuplicate(List<Integer> list) {
		Set<Integer> set = new HashSet<>(list);
		List<Integer> uniqueList = new ArrayList<>(set);
		
		for(Integer i : uniqueList) {
			System.out.print(i + " ");
		}
	}
}
```
<br>
**최빈값 구하기**<br>
`console로부터 정수를 입력받아 가장 많이 입력된 정수와 빈도수를 출력하시오`
```java
import java.util.*;

public class Question04 {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		
		Map<Integer, Integer> map = new HashMap<>();
		
		int maxValue = 0;
		int maxKey = 0;
		
		while(true) {
			System.out.println("정수를 입력하시오. (0 입력 시 종료)");
			int num = input.nextInt();
			if(num == 0) {
				break;
			}
			if(map.containsKey(num)) {
				int value = map.get(num);
				map.put(num, ++value);
				if(value > maxValue) {
					maxValue = value;
					maxKey = num;
				}
			} else {
				map.put(num, 1);
			}
		}
		
		System.out.println("종료되었습니다.");
		System.out.println("가장 많이 입력된 정수는 : " + maxKey + " 횟수는 : " + maxValue);
		
		input.close();
	}
}
```
<br>
**state와 capital**<br>
`console로 입력받은 state의 capital을 출력하는 프로그램을 만드시오.`
```java
import java.util.*;

public class Question05 {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		
		Map<String,String> map = getData();
		Set<String> keySet = map.keySet();
		
		while(true) {
			System.out.println("state를 입력하시오.(none 입력시 종료)");
			String str = input.nextLine();
			if(str.equals("none")) {
				break;
			} else if(keySet.contains(str)) {
				System.out.println(map.get(str));				
			} else {
				System.out.println("해당하는 state가 없습니다.");
			}
		}
		System.out.println("---종료---");
		input.close();
	}
	// 미국 50개 state와 주도(capital)을 map으로 관리하는 메소드
	public static Map<String, String> getData() {
		Map<String, String> map = new HashMap<String, String>();

		String[][] data = {
			{"Alabama", "Montgomery"}, {"Alaska", "Juneau"}, {"Arizona", "Phoenix"},
			{"Arkansas", "Little Rock"}, {"California", "Sacramento"},
			{"Colorado", "Denver"}, {"Connecticut", "Hartford"}, 
			{"Delaware", "Dover"}, {"Florida", "Tallahassee"}, 
			{"Georgia", "Atlanta"},{"Hawaii", "Honolulu"}, {"Idaho", "Boise"},
			{"Illinois", "Springfield"}, {"Indiana", "Indianapolis"},
			{"Iowa Des", "Moines"}, {"Kansas", "Topeka"}, {"Kentucky","Frankfort"}, 
			{"Louisiana", "Baton Rouge"}, {"Maine", "Augusta"}, 
			{"Maryland", "Annapolis"}, {"Massachusetts", "Boston"}, 
			{"Michigan", "Lansing"}, {"Minnesota", "Saint Paul"}, 
			{"Mississippi", "Jackson"}, {"Missouri", "Jefferson City"}, 
			{"Montana", "Helena"}, {"Nebraska", "Lincoln"}, 
			{"Nevada	", "Carson City"}, {"New Hampshire", "Concord"}, 
			{"New Jersey", "Trenton"}, {"New Mexico", "Santa Fe"}, 
			{"New York", "Albany"}, {"North Carolina", "Raleigh"}, 
			{"North Dakota", "Bismarck"},{"Ohio", "Columbus"},
			{"Oklahoma", "Oklahoma City"}, {"Oregon", "Salem"}, 
			{"Pennsylvania", "Harrisburg"}, {"Rhode Island", "Providence"}, 
			{"South Carolina", "Columbia"}, {"South Dakota", "Pierre"}, 
			{"Tennessee", "Nashville"}, {"Texas", "Austin"}, 
			{"Utah", "Salt Lake City"}, {"Vermont", "Montpelier"}, 
			{"Virginia", "Richmond"}, {"Washington", "Olympia"}, 
			{"West Virginia", "Charleston"}, {"Wisconsin", "Madison"}, 
			{"Wyoming", "Cheyenne"}};

		for (int i = 0; i < data.length; i++) {
			map.put(data[i][0], data[i][1]);
		}

		return map;
	}
}
```
<br>
**두 난수의 합**<br>
`console로부터 두 난수의 합을 입력받아 결과를 출력하시오.`<br>
`이미 입력받은 값은 HashSet에 저장하여 관리하시오.`
```java
import java.util.*;

public class Question06 {
	public static void main(String[] args) {
		int number1 = (int)(Math.random() * 10);
		int number2 = (int)(Math.random() * 10);

		// Create an set
		Set<Integer> answers = new HashSet<Integer>();

		// 1. Scanner를 통해 두 숫자의 합계의 추측값을 입력 받을 것
		// 2. while문을 수행하면서 만약 합계가 맞으면 정답이라고 출력할 것
		//    - 정답이 아니면, 정답이 아니라고 출력하면서 다시 입력하라고 메세지를 출력할 것
		//    - 정답이 아닌 경우는 answers에 입력할 것 
		//      (단, answers에 이미 이전에 입력했으면 이미 입력했다는 메세지를 출력할 것
		Scanner input = new Scanner(System.in);
		int correct = number1 + number2;
		while(true) {
			System.out.println("두 난수의 합을 추측해보시오.");
			int answer = input.nextInt();
			if(answer == correct) {
				System.out.println("정답");
				break;
			}
			System.out.println("정답이 아닙니다. 다시 입력하세요.");
			if(answers.contains(answer)) {
				System.out.println("이미 입력했던 답입니다.");
			} else {
				answers.add(answer);
			}
		}
		input.close();
	}
}
```
<br>
**별 출력하기**
```java
public class Question01 {
	public static void main(String[] args) {
		//    *
		//   ***
		//  *****
		// *******
		//*********		
		int auxiliary = 0;
		for(int i=5;i>0;i--) {
			for(int j=1;j<10;j++) {
				if(i <= j && (i+auxiliary) >= j) {
					System.out.print("*");
				}else System.out.print(" ");
			}
			System.out.println();
			auxiliary += 2;
		}
		System.out.println();
		
		//*********
		// *******
		//  *****
		//   ***
		//    *
		for(int i=0;i<5;i++) {
			for(int j=1;j<10;j++) {
				if(j>i && (j-i) < auxiliary) {
					System.out.print("*");
				} else System.out.print(" ");
			}
			System.out.println();
			auxiliary -= 2;
		}
		System.out.println();
		
		//    *
		//   ***
		//  *****
		// *******
		//*********	
		//*********
		// *******
		//  *****
		//   ***
		//    *
		for(int i=5;i>0;i--) {
			for(int j=1;j<10;j++) {
				if(i <= j && (i+auxiliary) >= j) {
					System.out.print("*");
				}else System.out.print(" ");
			}
			System.out.println();
			auxiliary += 2;
		}
		for(int i=0;i<5;i++) {
			for(int j=1;j<10;j++) {
				if(j>i && (j-i) < auxiliary) {
					System.out.print("*");
				} else System.out.print(" ");
			}
			System.out.println();
			auxiliary -= 2;
		}			
	}
}
```
<br>
**2차원 배열 회전**<br>
`주어진 2차원 배열을 90, 180, 270도로 회전한 결과를 출력하시오.`
```java
public class Question02 {
	public static void main(String[] args) {
		int[][] array = {
				{1, 0, 0},
				{1, 1, 1},
				{1, 0, 1},
				{1, 0, 1}
		};
		System.out.println("출력\n");
		for(int i=0;i<array.length;i++) {
			for(int j=0;j<array[0].length;j++) {
				System.out.print(array[i][j] + " ");				
			}
			System.out.println();
		}
		
		System.out.println("\n" + 90);
		for(int i=0;i<array[0].length;i++) {
			for(int j=array.length-1;j>=0;j--) {
				System.out.print(array[j][i] + " ");
			}
			System.out.println();
		}
		
		System.out.println("\n" + 180);
		for(int i=array.length-1;i>=0;i--) {
			for(int j=array[0].length-1;j>=0;j--) {
				System.out.print(array[i][j] + " ");
			}
			System.out.println();
		}
		
		System.out.println("\n" + 270);
		for(int i=array[0].length-1;i>=0;i--) {
			for(int j=0;j<array.length;j++) {
				System.out.print(array[j][i] + " ");
			}
			System.out.println();
		}
	}
}
```
<br>
**MyStack 만들기**<br>
`Stack과 동일한 동작을하는 MyStack 클래스를 작성하시오.`
```java
import java.util.ArrayList;

public class MyStack extends ArrayList {
	private java.util.ArrayList<Object> list;

	// Constructor
	public MyStack() {
		list = new java.util.ArrayList<Object>();
	}

	// Add a new element to the top of this stack
	public void push(Object o) {
		list.add(0, o);
	}

	// Return the top element in this stack without removing it
	public Object peek() {
		return list.get(0);
	}

	// Return an remove the top element in this stack
	public Object pop() {	
		return list.remove(0);
	}

	// Return a string of all elements in MyStack
	@Override
	public String toString() {
		return list.toString();
	}
}
```
```java
import java.util.Scanner;

public class Quiz01 {

	public static void main(String[] args) {
		// Create a Scanner
		Scanner input = new Scanner(System.in);

		// Create a MyStack
		MyStack stack = new MyStack();

		// Prompt the user to enter five strings
		System.out.print("Enter five strings: ");
		for (int i = 0; i < 5; i++) {
			stack.push(input.next());	
		}
		
//		String num = (String)(stack.peek());
//		System.out.println("peek 값 : " + num);
//		
//		stack.pop();
//		stack.pop();

		// Display in reverse order
		System.out.println("Stack: " + stack.toString());
		
		input.close();
	}
}
```
<br>
**인원정보 출력 프로그램**<br>
`학교의 학생과 직원을 구분하여 정보를 저장한 뒤 전체 인원정보, 랜덤한 인원정보를 출력하시오.`
```java
public abstract class Person {
	private String name;
	private String age;
	private String address;
	
	Person() {	}
	
	Person(String name, String age, String address) {
		this.name = name;
		this.age = age;
		this.address = address;
	}
	
	abstract void sayInfo();

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAge() {
		return age;
	}

	public void setAge(String age) {
		this.age = age;
	}
	
	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}	
}
```
```java
public class Student extends Person {
	private String subject;
	
	Student() {	}
	
	Student(String name, String age, String address, String subject) {
		super(name, age, address);
		this.subject = subject;
	}
	
	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	@Override
	void sayInfo() {
		System.out.println("이름: " + super.getName());
		System.out.println("주소: " + super.getAddress());
		System.out.println("나이: " + super.getAge());
		System.out.println("수강과목: " + this.getSubject());
	}
}
```
```java
public class Officer extends Person {
	private String job;
	
	Officer() {	}
	
	Officer(String name, String age, String address, String job) {
		super(name, age, address);
		this.job = job;		
	}
	
	public String getJob() {
		return job;
	}

	public void setJob(String job) {
		this.job = job;
	}

	@Override
	void sayInfo() {
		System.out.println("이름: " + super.getName());
		System.out.println("주소: " + super.getAddress());
		System.out.println("나이: " + super.getAge());
		System.out.println("직업: " + this.getJob());
	}
}
```
```java
import java.util.*;

public class SchoolManageMent {
	static List<Person> mems = new ArrayList<>();
	
	void printInfo() {
		for(Person person : mems) {
			person.sayInfo();
			System.out.println();
		}
	}
	
	void printRandomInfo() {
		Random random = new Random();
		int idx = random.nextInt(mems.size()-1);
		
		mems.get(idx).sayInfo();
		System.out.println();
	}
}
```
```java
import java.util.Scanner;

public class MainEx {
	public static void main(String[] args) {
		SchoolManageMent manage = new SchoolManageMent();
		boolean run = true;
		Scanner sc = new Scanner(System.in);
		int command = 0;
		
		SchoolManageMent.mems.add(new Student("김민태", "21", "서울시", "수학"));
		SchoolManageMent.mems.add(new Student("강종민", "24", "경기시", "국어"));
		SchoolManageMent.mems.add(new Student("강현빈", "23", "구리시", "미술"));
		SchoolManageMent.mems.add(new Student("한순민", "22", "하남시", "영어"));
		SchoolManageMent.mems.add(new Officer("김정태", "40", "서울시", "교사"));
		SchoolManageMent.mems.add(new Officer("김민태", "45", "서울시", "행정직원"));
		SchoolManageMent.mems.add(new Officer("이구민", "46", "서울시", "교장"));
		SchoolManageMent.mems.add(new Officer("노태현", "48", "서울시", "사장"));
		
		while(run) {
			System.out.println("메뉴 : 1.전체 인원 출력 2.랜덤하게 인원 출력 3.종료");
			command = sc.nextInt();
			
			switch(command) {
			case 1:
				manage.printInfo();
				break;
			case 2:
				manage.printRandomInfo();
				break;
			case 3:
				run = false;
				break;
			}
		}
		sc.close();
	}
}
```
<br>
**계산기 만들기**<br>
`정수의 +, -, *, / 를 수행하여 결과를 출력하는 계산기 프로그램을 만드시오.`
```java
public interface Calculator {
	void add(int num1, int num2);
	void sub(int num1, int num2);
	void divide(int num1, int num2);
	void multiple(int num1, int num2);
}
```
```java
public class CasioCal implements Calculator {

	@Override
	public void add(int num1, int num2) {
		System.out.println("합 은: " + (num1 + num2));
	}

	@Override
	public void sub(int num1, int num2) {
		System.out.println("빼기는: " + (num1 - num2));
	}

	@Override
	public void divide(int num1, int num2) {
		if(num2 != 0) {
			System.out.println("나누기는: " + (num1 / num2));
		} else System.out.println("0으로 나눌 수 없습니다.");
	}

	@Override
	public void multiple(int num1, int num2) {
		System.out.println("곱하기는: " + (num1 * num2));
	}
}
```
```java
import java.util.Scanner;

public class MainEx {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		Calculator calc = new CasioCal();
		
		while(true) {
			System.out.println("------------------------------------------");
			System.out.println("1.더하기 | 2.빼기 | 3.나누기 | 4.곱하기 | 5.종료");
			System.out.println("------------------------------------------");
			System.out.print("선택> ");
			int command = input.nextInt();
			
			if(command == 5) {
				System.out.println("프로그램이 종료되었습니다.");
				break;
			} else if(command < 1 || command > 5) {
				System.out.println("메뉴 중에서 선택하세요");
				continue;
			}
			System.out.println("첫번째 숫자를 입력하세요.");
			int num1 = input.nextInt();
			System.out.println("두번째 숫자를 입력하세요.");
			int num2 = input.nextInt();
			switch(command) {
			case 1:
				calc.add(num1, num2);
				break;
			case 2:
				calc.sub(num1, num2);
				break;
			case 3:
				calc.divide(num1, num2);
				break;
			case 4:
				calc.multiple(num1, num2);
				break;
			}
		}
		input.close();
	}
}
```
<br><br>


