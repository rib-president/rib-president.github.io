---
title: "10주차 HTML/CSS/Java Script Study"
excerpt: "2021-12-27 ~ 2021-12-31"

toc: true
toc_sticky: true
categories:
  - Study
---
<br>
# HTML 태그
---
**HTML :** Hypertext Markup Language, 웹 브라우저를 통해 사용자에게 보여지는 웹페이지를 구현하는 언어<br>
<br>
기본구조

```html
<!DOCTYPE html>		<!--html 문서의 시작-->
<html>
	<head>
		<!-문서의 지시(메타데이터)-->
		<meta charset="utf-8">	<!--캐릭셋 설정-->
	</head>
	<body>
		<!--레이아웃 및 실질적으로 그리는 내용-->
	</body>
</html>
```

<br><br>
## 태그(Tag)
HTML 문서의 기본 구성 요소(element), <태그명>내용</태그명> 형태로 작성<br>
태그 안에는 태그명과 속성을 쓸 수 있음<br>
속성은 키(key)와 문자열 값(value) 형식으로 작성(key = "value")
<br><br>
`ex) <button style="color: red; background-color: yellow;">안녕하세요</button>`<br>
`결과>` <button style="color: red; background-color: yellow;">안녕하세요</button>

<br>

* **`<!--comment-->` :** 주석
* **`<br>` :** 줄바꿈
* **`<p></p>` :** 단락태그
* **`<pre></pre>` :** 엔터를 인지하는 태그
* **`<ul><li></li></ul>` :** 순서가 없는 리스트 태그

```html
<ul style="background-color: yellow;">
	<li>안녕하세요</li>
	<li>반갑습니다</li>
	<li>안녕히계세요</li>
</ul>
```

결과>
<ul style="background-color: yellow;">
	<li>안녕하세요</li>
	<li>반갑습니다</li>
	<li>안녕히계세요</li>
</ul>

<br>
* **`<ol><li></li></ol>` :** 순서가 있는 리스트 태그

```html
<ol style="background-color: salmon;">
	<li>안녕하세요</li>
	<li>반갑습니다</li>
	<li>안녕히계세요</li>
</ol>
```

결과>
<ol style="background-color: salmon;">
	<li>안녕하세요</li>
	<li>반갑습니다</li>
	<li>안녕히계세요</li>
</ol>

<br>
* **`<h1></h1>` :** 구획단계 태그(h1이 가장 높고 h6이 가장 낮음)

```html
<h1>치킨</h1>
<h2>치킨</h2>
<h3>치킨</h3>
<h4>치킨</h4>
<h5>치킨</h5>
<h6>치킨</h6>
```

결과>

<img src="https://user-images.githubusercontent.com/57750308/147845338-efaf93f9-6f19-414a-95e3-f0f5156e5caa.png">

<br>
* **`<hr>` :** 구분선 태그(밑줄 한 줄이 그어짐)
* **`<div></div>` :** 레이아웃 용 태그(CSS에서 많이 사용)
  * 여러 개 이어붙일 경우 아래로 붙음
* **`<span></span>` :** 특정 글자 컨트롤할 때 사용되는 태그
  * 여러 개 이어붙일 경우 오른쪽으로 붙음

```html
<!--div와 span 비교-->
<div style="border: 1px solid black;">div는 아래로 붙어요</div>
<div style="border: 1px solid black;">div는 아래로 붙어요</div>
<div style="border: 1px solid black;">div는 아래로 붙어요</div>
<br>
<span style="border: 1px solid blue;">span은 오른쪽으로 붙어요</span>
<span style="border: 1px solid blue;">span은 오른쪽으로 붙어요</span>
<span style="border: 1px solid blue;">span은 오른쪽으로 붙어요</span>
<br>
<div>span으로
	<span style="font-size: 20px; color: red; font-weight: bold;">특정 글자</span>
컨트롤이 가능합니다</div>
```

결과>
<div style="border: 1px solid black;">div는 아래로 붙어요</div>
<div style="border: 1px solid black;">div는 아래로 붙어요</div>
<div style="border: 1px solid black;">div는 아래로 붙어요</div>
<br>
<span style="border: 1px solid blue;">span은 오른쪽으로 붙어요</span>
<span style="border: 1px solid blue;">span은 오른쪽으로 붙어요</span>
<span style="border: 1px solid blue;">span은 오른쪽으로 붙어요</span>
<br>
<div>span으로 <span style="font-size: 20px; color: red; font-weight: bold;">특정 글자</span> 컨트롤이 가능합니다</div>

<br>
* **`<a></a>` :** 링크 태그, 상대경로/절대경로(도메인 주소) 모두 가능
  * `href="경로"` : 해당 경로로 페이지 이동
* **`<img>` :** 이미지 태그
  * `src="경로"` : 경로상 이미지를 화면에 띄움
  * `alt="텍스트"` : 이미지 없을 경우 엑스박스 옆에 나오는 글
  * `title="텍스트"` : 이미지에 마우스오버했을 때 나오는 글

```html
<!--github.com으로 연결되는 이미지 링크 태그-->
<a href="https://github.com"><img src="존재하는 이미지경로.jpg" title="github로 이동" width="300px"></a>
<br>
<a href="~~"><img src="존재하지 않는 이미지경로.jpg" alt="없는 이미지&없는 링크예요"></a>
```

결과>

<a href="https://github.com" target="blank"><img src="https://user-images.githubusercontent.com/57750308/147844934-61280785-0455-4351-b192-e1981aed47b7.jpg" title="github로 이동" width="300px"></a>
<br>
<a href="~~" target="blank"><img src="존재하지 않는 이미지경로.jpg" alt="없는 이미지&없는 링크예요"></a>

<br>
* **`<table></table>` :** 테이블 태그
  * **`<tr></tr>` :** 테이블의 행 태그
  * **`<td></td>` :** 테이블의 열 태그(행 내부에 존재) 

```html
<table>
	<thead>		<!--시맨틱 태그 : 단순히 의미를 주는 태그-->
		<tr>
			<th>이름</th>	<!--헤더셀(제목), td의 일종-->
			<td>포지션</td>
			<td>kda</td>
		</tr>
	</thead>
	<tbody>		<!--시맨틱 태그-->
		<tr>
			<td>야스오</td>
			<td>미드</td>
			<td>3/11/6</td>
		</tr>
		<tr>
			<td>탈론</td>
			<td>정글</td>
			<td>8/3/11</td>
		</tr>
	</tbody>
</table>
```

결과>

<table>
	<thead>		<!--시맨틱 태그 : 단순히 의미를 주는 태그-->
		<tr>
			<th>이름</th>	<!--헤더셀(제목), td의 일종-->
			<td>포지션</td>
			<td>kda</td>
		</tr>
	</thead>
	<tbody>		<!--시맨틱 태그-->
		<tr>
			<td>야스오</td>
			<td>미드</td>
			<td>3/11/6</td>
		</tr>
		<tr>
			<td>탈론</td>
			<td>정글</td>
			<td>8/3/11</td>
		</tr>
	</tbody>
</table>

<br>
* **`<input>` :** 입력양식, type 속성에 따라 다양한 형태
  * `type="text"` : 텍스트 입력이 가능한 입력란
    * `placeholder` : 입력란에 기본으로 적혀있는 텍스트(입력하면 사라짐)
  * `type="password"` : 입력하는 문자가 ***로 가려짐
  * `type="email"` : 이메일 형식으로 입력
  * `type="button"` : 버튼 타입
    * `value="텍스트"` : 버튼에 나타날 텍스트
  * `type="color"` : 색상표로 색상 선택, rgb값 입력 가능
  * `type="date"` : 달력으로 날짜 선택, 직접 날짜 입력 가능
  * `type="checkbox"` : 체크박스(중복 선택 가능)
  * `type="radio"` : 라디오 버튼(하나만 선택 가능)
    * `name="이름"` : name이 같은 버튼 중 하나만 선택 가능
    * `checked` : default로 선택되어 있는 버튼
  * `type="file"` : 파일 선택
    * `accept="image/*"` : 이미지만 선택가능하도록 함
    * `multiple` : 여러 파일 선택 가능하도록 함


```html
텍스트 : <input type="text" placeholder="텍스트를 입력하시오" style="width: 300px;"><br>
비밀번호 : <input type="password" style="width: 300px;"><br>
이메일 : <input type="email" style="width: 300px;"><br>
<input type="button" value="버튼"><br>
색상 선택 : <input type="color" style="width: 100px;"><br>
날짜 선택 : <input type="date" style="width: 200px;"><br>
치킨 <input type="checkbox">
피자 <input type="checkbox">
햄버거 <input type="checkbox"><br>
민초단 <input type="radio" name="mintChoco" checked>
반민초단 <input type="radio" name="mintChoco"><br>
<input type="file" accept="image/*" multiple>
```

결과><br>
텍스트 : <input type="text" placeholder="텍스트를 입력하시오" style="width: 300px;"><br>
비밀번호 : <input type="password" style="width: 300px;"><br>
이메일 : <input type="email" style="width: 300px;"><br>
<input type="button" value="버튼"><br>
색상 선택 : <input type="color" style="width: 100px;"><br>
날짜 선택 : <input type="date" style="width: 200px;"><br>
치킨 <input type="checkbox">
피자 <input type="checkbox">
햄버거 <input type="checkbox"><br>
민초단 <input type="radio" name="mintChoco" checked>
반민초단 <input type="radio" name="mintChoco"><br>
<input type="file" accept="image/*" multiple>

<br>
* **`<select></select>` :** 드롭다운 리스트
  * `<option></option>` : 리스트에서 선택가능한 옵션
    * `selected` : 기본값으로 설정된 옵션

```html
<select>
	<option>서울</option>
	<option selected>속초</option>
	<option>제주</option>
	<option>포항</option>
</select>
```	

결과>
<select>
	<option>서울</option>
	<option selected>속초</option>
	<option>제주</option>
	<option>포항</option>
</select>

* **`<textarea></textarea>` :** 긴 문자 입력 가능한 입력란
  * `rows="크기"` : 행 크기
  * `cols="크기"` : 열 크기

```html
<textarea rows="10" cols="50" placeholder="텍스트를 입력하시오" style="border: 1px solid gray;"></textarea>
```

결과>

<textarea rows="10" cols="50"  placeholder="텍스트를 입력하시오" style="border: 1px solid gray;"></textarea>


<br>
* 특수문자
  * **`&nbsp;` :** 띄어쓰기
    * HTML에서는 스페이스바를 여러 칸 입력해도 한 칸만 인식됨
  * **`&lt;` :** <
  * **`&gt;` :** >
  * **`&amp;` :** &
  * **`&quot;` :** "
  * **`&copy:` :** ⓒ 저작권표시


<br><br>
# CSS
---
HTML 태그를 세밀하게 정의, 꾸밈<br>
<br>
**CSS의 기본구조**

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            /* CSS 작성 */

            선택자 선택한요소 {
		속성 : 값;
	} 

        </style>
    </head>
    <body>
    </body>
</html>
```

<br><br>

## 선택자
1. 전체 선택자(*) : 모든 태그들
2. 태그 선택자(태그명) : 특정 태그들(ex. li, div)
3. **아이디 선택자(#) :** 단 하나의 엘리먼트
4. **클래스 선택자(.) :** 특정 클래스명을 가지고 있는 엘리먼트들
<br>
<br>

* 전체 선택자
  * head, body, style, ul 등 모든 HTML 태그 포함

```css
* {
	/*전체 태그의 margin과 padding을 0으로 주고 시작*/
	margin: 0px;
	padding: 0px;
}
```

* 태그 선택자

```css
p, div { 	
	/* 콤마로 구분하여 여러 태그에 적용 가능*/
	color: red;
}
```

* **아이디 선택자**
  * 1 아이디 : 1 엘리먼트
  * 동일한 아이디를 여러 엘리먼트가 가지면 안됨(자바스크립트 에러 발생)

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #red {color: red;}
            #yellow {color: yellow;}
        </style>
    </head>
    <body>
        <div id="red">빨간색</div>
        <div id="yellow">노란색</div>
    </body>
</html>
```

결과>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #red {color: red;}
            #yellow {color: yellow;}
        </style>
    </head>
    <body>
        <div id="red">빨간색</div>
        <div id="yellow">노란색</div>
    </body>
</html>

<br>
* **클래스 선택자**
  * 동일 클래스끼리 같은 스타일 적용됨
  * 다른 태그끼리도 클래스로 묶을 수 있음
  * 하나의 태그에 여러 클래스 적용 가능

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            .red {color: red;}
            .blue {color: blue;}
            .bigSize {font-size: 50px;}
            .bold {font-weight: bold;}
        </style>
    </head>
    <body>
        <div class="red bigSize">큰 빨간색</div>
        <div class="blue bigSize">큰 파란색</div>
        <div class="blue bold">두꺼운 파란색</div>
    </body>
</html>
```

결과>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            .red {color: red;}
            .blue {color: blue;}
            .bigSize {font-size: 50px;}
            .bold {font-weight: bold;}
        </style>
    </head>
    <body>
        <div class="red bigSize">큰 빨간색</div>
        <div class="blue bigSize">큰 파란색</div>
        <div class="blue bold">두꺼운 파란색</div>
    </body>
</html>

<br><br>

**CSS 속성이 충돌날 때 범위가 좁은 속성이 우선시 됨**<br>
아이디 선택자 > 클래스 선택자 > 태그 선택 > 전체 선택자

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            div {color: white; background-color: black; font-weight: bold;}
            .class {color: red;}
            #id {color: yello;}
        </style>
    </head>
    <body>
        <div class="class" id="id">무슨 색이 적용될까요?</div>
    </body>
</html>
```

결과>
<img src="https://user-images.githubusercontent.com/57750308/147845791-61588786-3533-4fc1-80cc-4d89f42d48e8.png">

=>color는 가장 좁은 범위인 id 선택자의 속성이 적용<br>
=>background-color와 font-weight는 충돌나지 않아 태그 선택자의 속성이 적용됨

<br><br>

### 세밀한 선택자 지정
---
* 부모엘리먼트 엘리먼트
  * 부모엘리먼트의 자손엘리먼트 전부
  * `ex) ul li { }`
* 부모엘리먼트 > 엘리먼트
  * 부모엘리먼트 바로 밑에 있는 자식엘리먼트
  * `ex) ul > li { }`
* 엘리먼트.클래스명
  * 엘리먼트 중 해당 클래스에 속하는 엘리먼트
  * `ex) li.class { }`
* 엘리먼트#아이디명
  * 엘리먼트 중 해당 아이디를 가진 엘리먼트
  * `ex) li#id { }`
* 엘리먼트:nth-child(순번)
  * 엘리먼트 중 해당 순번의 엘리먼트(1부터 시작)
  * `ex) li:nth-child(2) { }`

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            ul li {	
                /* ul 이라는 태그 안쪽에 있는 모든 li => 자손 */
                color : royalblue;
            }

            ul > .a {	
                /* ul 이라는 태그 바로 안쪽에 있는 클래스a => 자식 */
                color : salmon;
            }

            li:nth-child(2n) {	
                /* 모든 li 중에서 짝수번인 것만 */
                font-size : 30px;
            }

            li:nth-child(2n-1)#b{	
                /* 모든 li 홀수번 중에서 아이디가 b인 것만 */
                font-size : 30px;
            }
        </style>
    </head>
    <body>
        <ul>
            <li class="a">홀수번이며 클래스 a</li>
            <li>짝수번</li>
            <li>홀수번</li>
            <li class="a">짝수번이며 클래스 a</li>
            <li id="b">홀수번</li>
        </ul>
    </body>
</html>
```

결과>

<img src="https://user-images.githubusercontent.com/57750308/147846099-6e41ad9c-0bac-4caf-ab2c-aa35118593aa.png">

<br><br>

## CSS 적용
1.style 태그 이용

```html
<style>
	.x1 { color: red; }
</style>
```

<br>
2.외부 css파일 로드

```css
/* 별도 작성한 css파일 (example.css)*/
.x2 { color: blueviolet; }
```
```html
<!--html 파일에 로드-->
<head>
	<meta charset="utf-8">

	<!-- css 로드-->
	<link href="example.css" rel="stylesheet">
</head>
```

<br>
3.태그 내에 속성으로 지정(단일 엘리먼트에 적용)

```html
<li style="color : blue; font-size : 50px;">안녕하세요4</li>
```

<br><br>

## 박스모델
CSS에서 가장 중요한 부분<br>
사실 거의 모든 HTML 태그는 박스<br><br>

`<body></body>` 박스의 크기는 브라우저 공간 처음부터 마지막 태그 까지임<br>
=> 웹브라우저 창 축소 -> body 박스 작아짐 -> body 안에 있는 태그들의 박스 크기도 작아짐<br>
<br>
<br>


### 박스의 구성요소
---
* **마진(margin)**
  * 경계선과 외부 요소 사이의 간격
  * margin-top, margin-left, margin-right, margin-bottom, margin(사방)
  * margin 공간은 인접한 박스끼리 공유
    * 인접한 박스끼리의 마진은 더 큰 값으로 적용됨
* 경계선(border)
  * 콘텐츠와 패딩을 포함한 경계를 나타내는 선
* **패딩(padding)**
  * 콘텐츠와 경계선 사이의 간격
  * padding-top, padding-left, padding-right, padding-bottom, padding(사방)
* 콘텐츠(contents)
  * 박스에 들어가는 텍스트나 이미지 등의 내용물
  * width, height는 콘텐츠가 들어가는 공간의 크기를 조절하는 것


<br><br>

### display block과 inline
---
display라는 속성의 값으로 block과 inline이 있음<br>
박스의 길이와 붙는 속성을 나타냄
<br><br>
**block :** 너비가 부모 엘리먼트의 길이와 같고 태그의 아래로 붙는 속성, 너비 조절 O (ex. div)<br>
**inline :** 너비가 내용(컨텐츠)와 같고 태그의 오른쪽으로 붙는 속성, 너비 조절 X (ex. span)<br>
`cf) inline-block : 너비조절이 가능하며 태그의 오른쪽으로 붙는 속성`<br>
<br>
<br>

### 속성 width
---
default는 auto(부모 박스크기에 영향)<br>
임의로 값을 설정하면 부모 박스크기와 관계없이 크기를 유지함`(ex. width: 400px;)`<br>
(부모박스가 작아져도 부모박스를 뚫고 나옴)<br>
<br>
컨텐츠(내용)보다 width가 작을 경우 아래로 길어짐 => height는 자동으로 내용만큼 길어짐<br>
(웬만해서 height는 건들지 않는 것이 좋음)<br>
<br>
<br>
<br>


## Layout
박스의 위치를 잡아주는 것(주로 div 사용)<br>
핵심은 오른쪽으로 갈 것인지 아래로 갈 것인지 설정하고 잘게 자르는 것<br>
<br>
<br>

### 속성 float
---
left 또는 right를 지정하여 박스가 왼쪽 또는 오른쪽에 붙게함<br>
display가 block인 박스도 span처럼 옆으로 붙고 컨텐츠의 크기만큼 박스 크기가 정해짐<br><br>

부모 박스의 크기가 줄면 박스가 아래로 내려가 레이아웃이 깨짐<br>
=> 일반적으로 박스들을 감싸는 너비가 고정된 wrapper 박스를 생성<br>
=> wrapper 박스는 **overflow: hidden;** 속성을 가져야함<br>
(설정하지 않으면 wrapper 박스의 높이는 0)

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper {
		/* 평균적인 웹사이트 wrapper의 width는 1200px */
                width : 600px;
                /* 
                    상/하 0px 좌우는 auto로 두어 브라우저 창 크기에 관계없이
                    항상 가운데에 위치하게됨
                 */
                margin: 0px auto;
                background-color: cornflowerblue;
                overflow: hidden;
            }

            #wrapper div {
                float: left;
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div style="float: right;">안녕히계세요</div>
        </div>
    </body>
</html>
```

결과>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper {
                width : 600px;

                margin: 0px auto;
                background-color: cornflowerblue;
                overflow: hidden;
            }

            #wrapper div {
                float: left;
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div style="float: right;">안녕히계세요</div>
        </div>
    </body>
</html>


<br><br>

### flex와 grid
---
최근에 나온 레이아웃 잡기 쉽게 도와주는 CSS
<br>
<br>

**flex**
* display모드 중 하나
* 부모(컨테이너)는 overflow: hidden; 자식 박스(아이템, 엘리먼트)들은 float: left; 적용됨
* 한 행의 자식 컨텐츠들의 높이가 다른 경우 일괄적으로 제일 긴 컨텐츠로 높이를 맞춤
  * `align-items : stretch;` default 값
  * `align-items : flex-start;`로 설정하면 컨텐츠 크기에 따라 각기 다른 높이를 가짐(float, overflow일때와 동일)
* 부모의 width를 자식 박스가 넘는 경우 자식박스의 크기를 줄여 부모 박스 크기에 맞춤
  * `flex: nowrap;` default 값
  * `flex : wrap;` 로 설정하면 부모의 width를 넘는 자식은 아래로 내려가게 함
* **flex-grow :** 자식 박스(아이템)에 설정되는 박스 크기 비율
  * `ex) flex-grow: 1;` 컨테이너가 아이템의 수 n으로 균등하게 등분됨

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper2 {
                width : 600px;
                margin: 0px auto;
                background-color: #bbdd7c;
                display: flex;
            }

            #wrapper2 div {
                border: 1px solid black;
                flex-grow: 1;
            }
        </style>
    </head>
    <body>
        <div id="wrapper"2>
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div>안녕히계세요</div>
        </div>
    </body>
</html>
```

결과>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper2 {
                width : 600px;
                margin: 0px auto;
                background-color: #bbdd7c;
                display: flex;
            }

            #wrapper2 div {
                border: 1px solid black;
                flex-grow: 1;
            }
        </style>
    </head>
    <body>
        <div id="wrapper2">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div>안녕히계세요</div>
        </div>
    </body>
</html>

<br>

`ex) align-items: flex-start, 마지막 div만 flex-grow: 3; >`
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper3 {
                width : 600px;
                margin: 0px auto;
                background-color: #bbdd7c;
                display: flex;
	    align-items : flex-start;
            }

            #wrapper3 div {
                border: 1px solid black;
                flex-grow: 1;
            }
        </style>
    </head>
    <body>
        <div id="wrapper3">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div style="flex-grow: 2;">안녕히계세요</div>
        </div>
    </body>
</html>

<br><br>
* justify-content
  * 컨테이너 속 아이템 정렬
  * default는 flex-start(왼쪽)
  * flex-end(오른쪽), center(가운데 정렬)
  * space-between
    * 컨테이너의 아이템 사이에 여백을 두어 처음 / 중간 / 끝을 전부 차지
  * space-around
    * 양 옆에 마진을 두고 아이템이 정렬됨

`ex) justify-content: flex-end; >`
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper4 {
                width : 600px;
                margin: 0px auto;
                background-color: #bbdd7c;
                display: flex;
                justify-content: flex-end;
            }

            #wrapper4 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper4">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div>안녕히계세요</div>
        </div>
    </body>
</html>

<br>

`ex) justify-content: center; >`
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper5 {
                width : 600px;
                margin: 0px auto;
                background-color: #bbdd7c;
                display: flex;
                justify-content: center;
            }

            #wrapper5 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper5">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div>안녕히계세요</div>
        </div>
    </body>
</html>


<br>


`ex) justify-content: space-between; >`
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper6 {
                width : 600px;
                margin: 0px auto;
                background-color: #bbdd7c;
                display: flex;
                justify-content: space-between;
            }

            #wrapper6 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper6">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div>안녕히계세요</div>
        </div>
    </body>
</html>

<br>
`ex) justify-content: space-around; >`
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper7 {
                width : 600px;
                margin: 0px auto;
                background-color: #bbdd7c;
                display: flex;
                justify-content: space-around;
            }

            #wrapper7 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper7">
            <div>안녕하세요<br>안녕하세요<br>안녕하세요</div>
            <div>반갑습니다</div>
            <div>안녕히계세요</div>
        </div>
    </body>
</html>

<br>
<br><br>

**grid**
* display모드 중 하나
* flex가 단방향, vector였다면 grid는 이중배열, matrix(행과 열)
* **grid-template-columns**
  * 열(col)을 설정
  * `1fr 1fr 1fr;` 또는 `repeat(3, 1fr);` => 비율이 1:1:1인 열 3개
  * `repeat(auto-fill, minmax(20%, auto));`
    * 최소 크기는 부모의 20%로 너비가 허용하는 최대 셀을 채움
    * auto-fill : 여백 남김
  * `repeat(auto-fill, minmax(20%, auto));`
    * 최소 크기는 부모의 20%로 너비가 허용하는 최대 셀을 채움
    * auto-fit : 여백 메꿈
* **grid-template-rows**
  * 행(row)을 설정
  * `200px 200px 500px;` => 높이가 200px, 200px, 500px인 행 3개
  * `repeat(3, minmax(100px, auto));`
    * 최소 높이는 100px 최대 높이는 자동인 3개 행
* 설정한 col, row의 수에 따라 n x m의 grid 생성됨
  * 설정된 row의 수를 넘어가는 아이템은 row 속성 적용받지 않고 아래 추가됨


```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper8 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                grid-template-rows: 30px 30px 60px;
            }

            #wrapper8 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper8">
            <div>아침입니다1</div>
            <div>점심입니다1</div>
            <div>저녁입니다1</div>
            <div>아침입니다2</div>
            <div>점심입니다2</div>
            <div>저녁입니다2</div>
            <div>아침입니다3</div>
            <div>점심입니다3</div>
            <div>저녁입니다3</div>
        </div>
    </body>
</html>
```

결과>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper8 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                grid-template-rows: 30px 30px 60px;
            }

            #wrapper8 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper8">
            <div>아침입니다1</div>
            <div>점심입니다1</div>
            <div>저녁입니다1</div>
            <div>아침입니다2</div>
            <div>점심입니다2</div>
            <div>저녁입니다2</div>
            <div>아침입니다3</div>
            <div>점심입니다3</div>
            <div>저녁입니다3</div>
        </div>
    </body>
</html>

<br>

`ex) repeat(auto-fill, minmax(20%, auto)); (row지정X)>`
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper9 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(20%, auto));
            }

            #wrapper9 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper9">
            <div>아침입니다1</div>
            <div>점심입니다1</div>
            <div>저녁입니다1</div>
        </div>
    </body>
</html>

<br>

`ex) repeat(auto-fit, minmax(20%, auto)); (row지정X)>`
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper10 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(20%, auto));
            }

            #wrapper10 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper10">
            <div>아침입니다1</div>
            <div>점심입니다1</div>
            <div>저녁입니다1</div>
        </div>
    </body>
</html>

<br>
<br>
* grid-column
  * 아이템에 지정
  * 해당 아이템의 시작 열과 차지할 공간 개수 설정
  * `grid-column : 1 / span 2;`
    * 시작 열은 첫 번째이고 2개 열을 차지

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper11 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
            }

            #wrapper11 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper11">
            <div style="grid-column : 1 / span 2;">아침입니다1</div>
            <div>점심입니다1</div>
            <div>저녁입니다1</div>
            <div>아침입니다2</div>
            <div>점심입니다2</div>
            <div>저녁입니다2</div>
            <div>아침입니다3</div>
            <div>점심입니다3</div>
            <div>저녁입니다3</div>
        </div>
    </body>
</html>
```

결과>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper11 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
            }

            #wrapper11 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper11">
            <div style="grid-column : 1 / span 2;">아침입니다1</div>
            <div>점심입니다1</div>
            <div>저녁입니다1</div>
            <div>아침입니다2</div>
            <div>점심입니다2</div>
            <div>저녁입니다2</div>
            <div>아침입니다3</div>
            <div>점심입니다3</div>
            <div>저녁입니다3</div>
        </div>
    </body>
</html>

<br>
* grid-row
  * 아이템에 지정
  * 해당 아이템의 시작 행과 차지할 공간 개수 설정
  * `grid-row : 2 / span 3;`
    * 시작 행은 두 번째이고 3개 행을 차지

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper12 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
            }

            #wrapper12 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper12">
            <div>아침입니다1</div>
            <div>점심입니다1</div>
            <div style="grid-row : 2 / span 3;">저녁입니다1</div>
            <div>아침입니다2</div>
            <div>점심입니다2</div>
            <div>저녁입니다2</div>
            <div>아침입니다3</div>
            <div>점심입니다3</div>
            <div>저녁입니다3</div>
        </div>
    </body>
</html>
```

결과>
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #wrapper12 {
                width : 600px;
                margin: 0px auto;
                background-color: orange;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
            }

            #wrapper12 div {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div id="wrapper12">
            <div>아침입니다1</div>
            <div>점심입니다1</div>
            <div style="grid-row : 2 / span 3;">저녁입니다1</div>
            <div>아침입니다2</div>
            <div>점심입니다2</div>
            <div>저녁입니다2</div>
            <div>아침입니다3</div>
            <div>점심입니다3</div>
            <div>저녁입니다3</div>
        </div>
    </body>
</html>

<br>
<br><br>

## bootstrap
CSS 사용을 편리하게 해줌<br>
다운로드 혹은 css파일과 js파일을 import하여 사용<br><br>

**bootstrap 사용시 Layout 구조**
* 최상단 wrapper 안에 container-fluid 박스 지정
* 항상 row로 시작
* **row 안에는 col이 존재**
  * bootstrap 하나의 row는 항상 12등분됨
    * col-3이 4개면 row가 꽉참
  * col, col-1 ~ col-12 까지 존재
  * col은 등분되고 남은 공간을 차지함
* 내용(contents)은 col에 작성
* depth는 **row-col-row-col-... 순**으로 깊어져야함
  * row-row 또는 col-col 안됨
* 버튼은 col 크기에 꽉 채움

```html
<html>
    <head>
        <meta charset="utf-8">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
        <style>
            .container-fluid div { border: 1px solid dodgerblue;}
        </style>
    </head>
    <body>
        <div style="width: 600px; margin: 0px auto;">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-3">3개 차지</div>
                    <div class="col-2">2개 차지</div>
                    <div class="col">나머지 7개 차지</div>
                </div>
                <div class="row">
                    <div class="col">
                        <div class="row">
                            <div class="col-5">토끼</div>
                            <div class="col-3">개</div>
                            <div class="col">고양이</div>
                        </div>
                        <div class="row">
                            <div class="col">야호</div>
                        </div>
                    </div>
                    <div class="col">멍멍</div>
                </div>
            </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    </body>
    
</html>
```

결과>

<img src="https://user-images.githubusercontent.com/57750308/147851128-661018fc-61b4-4191-a3c6-2947dc782715.png">

<br>
<br>
**margin과 padding :** 키워드로 조합하여 class에 적용
* **m** : margin
* **p** : padding
* **t** : top, **b** : bottom
* **s** : left(start), **e** : right(end)
* **x** : 좌우, **y** : 상하
* 생략 : 전체
* 값은 0~5 또는 auto
  * 픽셀이나 비율이 아닌 공학적인 숫자

`ex) <div class="row mt-5"></div>`<br>
<br>
<br>
**`<img class="img-fluid" src="경로">`**<br>
이미지는 부모 박스의 크기와 관계없이 고유의 크기를 유지함<br>
=>img-fluid 클래스를 적용하여 부모박스 크기에 맞춤
<br><br>

**아이콘 사용**<br>
`<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">`<br>
위 태그를 head에 import한 뒤 원하는 bootstrap 아이콘 태그 가져와 사용(아이콘은 text)<br>
<br><br>

<br><br><br>

# JavaScript
---
이벤트(동작)가 발생했을 때 처리를 담당<br>
이벤트 : 클릭, 마우스오버, 드래그, 키보드 타이핑 등<br>
<br>
위에서부터 아래로 차례대로 실행됨<br>
컴파일 언어가 아님 => console에서 한 줄 한 줄 실행 가능(대화형)<br>
<br><br>

## 변수
선언시 타입이 없음 -> 어떤 값이든지 var로 받음 or var도 생략 가능<br><br>
변수의 생성과 소멸이 다른 언어(스코프에 따른 생명주기)와 다름<br>
=> es6 버전 이후엔 스택에 쌓이는 변수와 클래스가 나옴<br>


```javascript
var a = 10;
var b = 20;
var c = a + b;
console.log(c);	// console에 출력

var d = "안녕하세요";
var e = '반갑습니다';
var a1 = 2.3333;
var a2 = true;
var a3 = false;

// 이미 선언된 변수지만 재선언 가능
var a = 10;
a = 20;
var a = 30;
console.log(a);   // 30

// 파이썬처럼 var 안 붙이고 바로 선언 가능(가독성 좋지 않아 권장X)
b = 10;
b = "안녕하세요";   // 다른 타입 값 넣기도 가능
console.log(b); // 안녕하세요


// es6 이후 변수 선언 방법(스코프에 따른 생명주기)
let a22 = 30;
let a33 = 40;

// es6 상수 생김
const a = 44;
// a44 = 50; 상수는 값 변경 불가

// let은 이미 선언된 변수 재선언 안됨
let a2 = 20;
// let a2 = 30; 에러발생
a2 = "안녕하세요";
console.log(a2);    // 다른 타입 값 넣기는 가능
a2 = 40;


// 타입 확인하는 API
var a5 = 10;
var test = typeof a5;   // typeof : 메모리 타입 조사하여 string으로 리턴
console.log(test);      // number
console.log(typeof test);   // string
```

<br>
<br>

## 연산자
```javascript
// 산술 연산자(+, -, *, /, %)
var a1 = 10;
var b1 = 20;
var result1 = a1 + b1;
console.log(result1);

var a2 = 5;
var b2 = 2;
var result2 = a2 / b2;
console.log(result2);   // 정수 연산인데 타입이 없어 2.5가 나옴
result2 = parseInt(a2 / b2);    // 정수로 변환
console.log(result2);

var a3 = 5;
var b3 = 2;
var result3 = a3 % b3;  // 나머지 연산
console.log(result3);


// 비교 연산자
// equals 대신 ==로 문자열 비교 가능
// 타입이 없어서 문자 "1"과 숫자 1 비교가 가능하고 심지어 "같다"임
var a4 = "1";
var b4 = 1;
if(a4 == b4) {
    console.log("같다");
} else {
    console.log("다르다");
}   // 같다

// === 형태까지 같은지 비교
if(a4 === b4) {
    console.log("같다");
} else {
    console.log("다르다");
} // 다르다

var a6 = 10;
var b6 = 20;
if(a6 > b6) {
    console.log("크다");
} else {
    console.log("작다");
}   // 작다

// 논리 연산자(&&, ||, ...)
var a7 = 10;
// 이중 비교가 가능
if(5 < a7 < 20) {
    console.log("a7은 5와 20 사이에 있다")
}

if(a7 > 5 && a7 < 20) {
    console.log("a7은 5보다 크고 20보다 작다.")
}

// 문자열 연산 +
var a8 = "안녕하세요" + 1234;
console.log(a8);    // 안녕하세요1234
```

<br><br>

## 제어문과 반복문
```javascript
// if문
var a = 13;

if(a > 10) {

}else if(a > 5) {

}else {

}

// a가 positive한 값이면 true, negative한 값(0, 음수)이면 false
if(a) {

} else {

}

// switch ~ case문
a = 3;
switch(a) {
    case 1:
        console.log("1입니다");
        break;
    case 2:
        console.log("2입니다");
        break;
    default:
        console.log("이도저도 아닙니다");
}

// for문
for(var i=1;i<=10;i++){
    console.log(i);
}

// 향상된 for문(두 가지 버전이 있음)
var arr = [1, 2, 3, 4, 4, 76, 856, 4];    // list 선언

// 옛 버전(es5 이전)
for(var i in arr) {
    console.log(i);     // list의 인덱스가 출력됨(type도 string임)
    console.log(arr[i]);    // 인덱스로 list에 접근하여 원소 출력
}

// es6 이후 향상된 for문
for(var data of arr) {
    console.log(data);  // list의 원소가 순서대로 출력됨
}


// while문
var i = 0;
while(true) {
    if(i == 10) {
        console.log("탈출");
        break;
    }
    i++;
}
```

<br><br>
## 배열
사실상 리스트에 가까우나 자바스크립트에서 배열이라고 부름

```javascript
var arr = [];   // 빈 배열 만들기
// 타입이 없기때문에 여러 형태 넣을 수 있음
arr = [3, 5, "안녕", false, null, 3.14]; // 초기값 활용

// 문법 : 접근, 수정, 삽입
console.log(arr[3]);    // get
arr[1] = "하하";    // 수정
arr[6] = "????";    // 추가

arr[10] = 777;  // idx 7,8,9 건너뛰고 10에 추가 가능(7,8,9는 empty)

// API적 사용(자료구조 활용)
console.log(arr.length);    // 배열 사이즈 확인
arr.push(1111111);  // 배열 끝에 값 추가
arr.push('ㅂㅂ');
arr.push(null);

// 향상된 for문으로 활용
for(data of arr) {
    console.log(data);
}
```

<br><br>

## JSON과 Map
java script에서 map과 object가 같음

```javascript
// JSON(java script object notation(선언법, 표현법, 문법))
var st1 = {};   // 비어있는 오브젝트 혹은 맵


function test1() {
    alert("공부합니다.");
}


// 맵 기준 : key는 score, value는 77
// object 기준 : score 필드에 77이라는 값이 있음(st1은 참조변수)
// object형태로 사용
st1 = {
    score : 77,
    name : '한조',
    age : 15,
    doStudy : test1	// 함수자체를 넣음
};

// 접근
st1.name = '트레이서';
console.log(st1.score);
console.log(st1.name);	// 트레이서
console.log(st1.age);

st1.doStudy();  // 메소드처럼 사용

// 맵 형태로 사용
var map1 = {};
map1['score'] = 40; // put, key는 'score' value는 40 
console.log(map1['score']); // get -> 40

// map 방식과 object 방식 섞어서 사용할 수는 있음(추천X)
// 헷갈리므로 처음 의도한 용도에 따른 방식으로 사용할 것 권장
// map이면 ['']로 접근, object면 .로 접근
var some = {
    a : 10,
    b : 20
};

console.log(some.a);
console.log(some['a']);

// 없으면 만듦
some.c = 30;
console.log(some.c);
console.log(some['c']);

some['d'] = 40;
console.log(some.d);
```

<br><br>


## function(함수)
java script의 함수는 리턴 타입이 없음

```javascript
function test1() {
    console.log("test1 호출됨");
}

// 호출
test1();
test1();
test1();


/* 
    null : 주소 값이 없음
    undefined : 정의가 되지 않음
*/

function test2(a, b) {
    // java script에서 제공하는 undefined 비교기능
    if(b == undefined) {
        console.log("undefined 컨트롤 가능하다")
    }
    console.log("test2 호출됨 : " + a + " : " + b)
}

test2(1, 2);
test2("안녕", 17);

// undefined로 b 값이 넘어감
test2(13);  // "undefined 컨트롤 가능하다"


// return type이 문법적으로 없어 return type을 지정할 필요가 없음
function test3() {
    return 13;
}

var value = test3();
console.log(value);	// 13

/*
    return type을 지정하지 않음 =>
        return 값이 없는 함수의 return을 받을 수 있음
*/
value = test1();
console.log(value); // undefined

function test4(a) {
    if(a > 10) {
        return "안녕하세요";
    }
    // a <= 10일 때는 undefined를 리턴
}

var result = test4(30);
console.log(result);    // 안녕하세요
result = test4(5);
console.log(result);    // undefined


// 함수의 주소를 변수에 넣는 것이 가능(java에서는 불가능 => 인터페이스로 구현)
// 해당 변수를 함수처럼 사용
var aaa = test3;
console.log(aaa());
```

<br><br>
### 다형성
---
함수의 주소를 변수에 대입가능 -> 다형성 구현됨

```javascript
function test2() {
    console.log("test2 호출됨");
}

function test3() {
    console.log("test3 호출됨");
}

// 함수를 호출한 뒤 리턴값을 변수 aaa에 대입
var aaa = test2();

// 함수 자체를 변수에 넣음(함수의 주소를 변수 aaa에 대입) - 호출X
aaa = test2;

// 둘 다 동일 함수 호출됨
aaa();
test2();

// 같은 변수 aaa에 함수 test3 대입
aaa = test3;	
aaa();	// test3 호출됨
=> 다형성구현(자바에서는 이걸 지원하지 않아 인터페이스 사용해야함)
```

<br>
<br>

### 익명함수와 콜백함수
익명함수 : 함수적 인터페이스를 구현하는 람다식과 같음<br>
콜백함수 : 파라미터로 전달되어 함수의 내부에서 실행되는 함수

```javascript
// 익명함수를 정의하여 변수에 대입
var ttt = function () {
    console.log("ggggggg");
};

ttt();	// ggggggg


// 콜백함수
function test10() {
    console.log("test10이 호출됨");
}

function test11() {
    console.log("test11이 호출됨");
}

function some(aaaa) {
    console.log("some 호출됨");
    aaaa();
}

some(test10);   // some 호출됨 -> test10이 호출됨
some(test11);   // some 호출됨 -> test11이 호출됨


// 파라미터로 익명함수 전달
// 콜백함수로 익명함수 사용
some(function () {
    console.log("익명함수 호출됨");
});     // some 호출됨 -> 익명함수 호출됨


// API와 익명함수
function test1() {
    console.log("안녕하세요");
}

// API. (함수, 시간) -> 5초 후에 넘긴 함수가 내부에서 호출됨(콜백됨)
setTimeout(test1, 5000);

// 콜백함수로 익명함수 사용
setTimeout(function () {
    console.log("반갑습니다");
    console.log("안녕하세요");
    setTimeout(function () {
        console.log("하하하하");
    }, 3000);
}, 5000);   // 5초 후에 반갑습니다안녕하세요 => 3초후에 하하하하
```

<br><br>

### 클래스 문법
---
함수를 사용하여 클래스를 정의함

```javascript
// 리터럴 방식
var st1 = {
    score : 30,
    name : '한조'
};

var st2 = {
    score : 70,
    name : '트레이서'
};


// 함수방식(함수가 생성자 역할을 함)
function Student(score, name) {
    // 필드 선언
    this.score = score;
    this.name = name;

    // 메소드 정의 -> 이렇게하면 new로 메모리 생성될 때마다 메소드 메모리도 계속 생성됨
    this.study = function() {
        console.log(this.name + "가 공부를 합니다.");
    };
}

// 그냥 함수 호출
var a = Student();  // a는 undefined


// new 키워드로 새로운 메모리를 생성해서 함수 호출 -> 메모리의 참조주소를 리턴
var b1 = new Student(50, '한조');  // b1은 메모리의 주소값
var b2 = new Student(40, '트레이서');

console.log(b1.name);	// 한조
console.log(b2.name);	// 트레이서

b1.study();	// 한조가 공부를 합니다.
b2.study();	// 트레이서 공부를 합니다.

// 대문자로 시작하는 API 함수들은 new로 생성하여 사용하는 것이 관례
var aa = new Date(123123123);
console.log(aa.getDate());
```

<br>
<br><br>

## DOM API
DOM(Document Object Model) : 문서객체모델, 트리구조<br>
Object : element, 태그를 뜻함<br><br>

DOM API : 엘리먼트를 컨트롤하는 API
<br><br>

### 접근
---
getElement : 단수의 엘리먼트에 접근하여 하나의 엘리먼트 리턴<br>
getElements : 복수의 엘리먼트에 접근하여 배열로 리턴<br>
=> 리턴 값은 엘리먼트의 참조 주소값<br>
<br>
document : 미리 선언된 변수/객체(html 문서 전체를 나타내는 루트 객체)

```html
<html>
    <head>
        <meta charset="utf-8">
        <script>
            function test1() {
                // ID로 접근
                var y1 = document.getElementById("y1");  // HTML element 리턴, 참조 주소값
                
	    // id가 y1인 엘리먼트의 텍스트를 출력
                console.log(y1.innerText);

	    // id가 y1인 엘리먼트의 텍스트를 "반갑습니다."로 변경
                y1.innerText = "반갑습니다.";
            }

            function test2() {
                // 클래스명으로 접근
                var ccs = document.getElementsByClassName("cc");

	    // 리턴받은 배열을 향상된 for문을 이용하여 내부 텍스트 변경
                for(e of ccs) {
                    e.innerText = "하하하하하히히히히";
                }
            }

            function test3() {
                // id x2에 있는 class cc만 하하하하로 변경
                var x2 = document.getElementById("x2");

                // element로 자식 엘리먼트 접근 가능
                var ccs = x2.getElementsByClassName("cc");
                for(e of ccs) {
                    e.innerText = "하하하하";
                }
            }

            function test4() {
                // querySelector는 무조건 첫 번째 1개만 리턴함 -> 반복문X
                // css 선택자 문자열로 접근
                var e = document.querySelector("#y1");
                e.innerText = "yyyyyy";
            }

            function test5() {  
                // querySelectorAll은 무조건 배열로 리턴(id의 경우 [0]로 꺼냄)
                // css 선택자 문자열로 접근 -> 한 번에 자식태그로 타고 갈 수 있음
                var elements = document.querySelectorAll("#x2 .cc");
                for(e of elements) {
                    e.innerText = "qwerqwerqwer";
                }
            }
        </script>
    </head>
    <body>
        <ul id="x1">
            <li class="cc">1</li>
            <li id="y1">2</li>
	<li>3</li>
            <li class="cc">4</li>
            <li class="cc">5</li>
        </ul>

        <ul id="x2">
            <li class="cc">6</li>
            <li class="cc">7</li>
        </ul>

        <button onclick="test1()">2번 변경</button>
        <button onclick="test2()">1, 4, 5, 6, 7번 변경</button>
        <button onclick="test3()">6, 7번 변경</button>
        <button onclick="test4()">2번 변경</button>
        <button onclick="test5()">6, 7번 변경</button>
    </body>
</html>
```

결과>

<html>
    <head>
        <meta charset="utf-8">
        <script>
            function test1() {
                // ID로 접근
                var y1 = document.getElementById("y1");  // HTML element 리턴, 참조 주소값
                
	    // id가 y1인 엘리먼트의 텍스트를 출력
                console.log(y1.innerText);

	    // id가 y1인 엘리먼트의 텍스트를 "반갑습니다."로 변경
                y1.innerText = "반갑습니다.";
            }

            function test2() {
                // 클래스명으로 접근
                var ccs = document.getElementsByClassName("cc");

	    // 리턴받은 배열을 향상된 for문을 이용하여 내부 텍스트 변경
                for(e of ccs) {
                    e.innerText = "하하하하하히히히히";
                }
            }

            function test3() {
                // id x2에 있는 class cc만 하하하하로 변경
                var x2 = document.getElementById("x2");

                // element로 자식 엘리먼트 접근 가능
                var ccs = x2.getElementsByClassName("cc");
                for(e of ccs) {
                    e.innerText = "하하하하";
                }
            }

            function test4() {
                // querySelector는 무조건 첫 번째 1개만 리턴함 -> 반복문X
                // css 선택자 문자열로 접근
                var e = document.querySelector("#y1");
                e.innerText = "yyyyyy";
            }

            function test5() {  
                // querySelectorAll은 무조건 배열로 리턴(id의 경우 [0]로 꺼냄)
                // css 선택자 문자열로 접근 -> 한 번에 자식태그로 타고 갈 수 있음
                var elements = document.querySelectorAll("#x2 .cc");
                for(e of elements) {
                    e.innerText = "qwerqwerqwer";
                }
            }
        </script>
    </head>
    <body>
        <ul id="x1">
            <li class="cc">1</li>
            <li id="y1">2</li>
            <li class="cc">4</li>
            <li class="cc">5</li>
        </ul>

        <ul id="x2">
            <li class="cc">6</li>
            <li class="cc">7</li>
        </ul>

        <button onclick="test1()">2번 변경</button>
        <button onclick="test2()">1, 4, 5, 6, 7번 변경</button>
        <button onclick="test3()">6, 7번 변경</button>
        <button onclick="test4()">2번 변경</button>
        <button onclick="test5()">6, 7번 변경</button>
    </body>
</html>

<br><br>

**this를 활용하여 부모 엘리먼트에 접근**

```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            #board div {
                border: 1px solid black;
            }
        </style>
        <script>
            function test6(eee) {
                // eee는 content 클래스 div의 자식 엘리먼트
                // eee의 바로 위 부모를 리턴하는 API
                var p = eee.parentElement;
                // eee.parentElement.parentElement.parentElement.parentElement; => <html>

	        // 자식 엘리먼트 중 title 클래스에 속한 엘리먼트 리턴
                var target = p.querySelector(".title");
                target.innerText = "반갑습니다";
                
                // eee.parentElement.getElementsByClassName("title")[0].innerText = "반갑습니다";
                //eee.parentElement.querySelector(".title").innerText = "반갑습니다";	=> 한 줄로 요약

                console.log("호출됨");
            }

            function test7(eee) {
                // 엘리먼트와 가장 가까운 부모 중 괄호()에 해당하는 엘리먼트 리턴
                // querySelector와 관련있음
                // depth가 깊을 때 유리(eee.parentElement.parentElement.~~~)
                var x = eee.closest(".content");
                
                // 엘리먼트 삭제(자식도 다 삭제됨)
                x.remove();

                // children : 자식엘리먼트 모두 리턴, [1] : 자식 중 인덱스 1
                //eee.parentElement.children[1];
            }
        </script>
    </head>
    <body>
        <div id="board">
            <div class="content" style="display: flex; border: 0px;">
                <div>1</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <!--해당 이벤트가 일어나 핸들러를 호출하는 element(아래의 div)가 this-->
                <!--this 중요!-->
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
            <div class="content" style="display: flex; border: 0px;">
                <div>2</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
            <div class="content" style="display: flex; border: 0px;">
                <div>3</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
            <div class="content" style="display: flex; border: 0px;">
                <div>4</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
        </div>
    </body>
</html>
```

결과>

<html>
    <head>
        <meta charset="utf-8">
        <style>
            #board div {
                border: 1px solid black;
            }
        </style>
        <script>
            function test6(eee) {
                // eee는 content 클래스 div의 자식 엘리먼트
                // eee의 바로 위 부모를 리턴하는 API
                var p = eee.parentElement;
                // eee.parentElement.parentElement.parentElement.parentElement; => <html>

	            // 자식 엘리먼트 중 title 클래스에 속한 엘리먼트 리턴
                var target = p.querySelector(".title");
                target.innerText = "반갑습니다";
                
                // eee.parentElement.getElementsByClassName("title")[0].innerText = "반갑습니다";
                //eee.parentElement.querySelector(".title").innerText = "반갑습니다";	=> 한 줄로 요약

                console.log("호출됨");
            }

            function test7(eee) {
                // 엘리먼트와 가장 가까운 부모 중 괄호()에 해당하는 엘리먼트 리턴
                // querySelector와 관련있음
                // depth가 깊을 때 유리(eee.parentElement.parentElement.~~~)
                var x = eee.closest(".content");
                
                // 엘리먼트 삭제(자식도 다 삭제됨)
                x.remove();

                // children : 자식엘리먼트 모두 리턴, [1] : 자식 중 인덱스 1
                //eee.parentElement.children[1];
            }
        </script>
    </head>
    <body>
        <div id="board">
            <div class="content" style="display: flex; border: 0px;">
                <div>1</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <!--해당 이벤트가 일어나 핸들러를 호출하는 element(아래의 div)가 this-->
                <!--this 중요!-->
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
            <div class="content" style="display: flex; border: 0px;">
                <div>2</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
            <div class="content" style="display: flex; border: 0px;">
                <div>3</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
            <div class="content" style="display: flex; border: 0px;">
                <div>4</div>
                <div class="title">안녕하세요</div>
                <div class="nick">한조</div>
                <div onclick="test6(this)">변경</div>
                <div onclick="test7(this)">삭제</div>
            </div>
        </div>
    </body>
</html>

<br><br>
<br>

### 속성(Attribute) 컨트롤
---
```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            .blueColor {color: blue;}
            .redColor {color: red;}
            .smallFont {font-size: 5px;}
            .bigFont {font-size: 30px;}
        </style>
        <script>
            function test8() {
                var e = document.getElementById("xx");

                // 속성을 변경(id, class, onclick 등 전부 속성임)
                // 주로 클래스 바꿀 때 사용
                // 적용할 속성(key), 값(value) 입력
                e.setAttribute("class", "redColor bigFont");
            }

            function test9() {
                var e = document.getElementById("xx");

                // 속성 class(key값)에 해당하는 value(string) 가져옴
                var value = e.getAttribute("class");
                alert(value);   // smallFont blueColor
            }
        </script>
    </head>
    <body>
        <div id="xx" class="blueColor smallFont">안녕하세요</div>
        <button onclick="test8()">테스트1</button>
        <button onclick="test9()">테스트2</button>
    </body>
</html>
```

결과>

<html>
    <head>
        <meta charset="utf-8">
        <style>
            .blueColor {color: blue;}
            .redColor {color: red;}
            .smallFont {font-size: 5px;}
            .bigFont {font-size: 30px;}
        </style>
        <script>
            // DOM... Attribute
            function test8() {
                var e = document.getElementById("xx");
                // 속성을 변경(id, class, onclick 등 전부 속성임)
                // 주로 클래스 바꿀 때 사용
                // 적용할 속성(key), 값(value) 입력
                e.setAttribute("class", "redColor bigFont");
            }

            function test9() {
                var e = document.getElementById("xx");
                // 속성 class(key값)에 해당하는 value(string) 가져옴
                var value = e.getAttribute("class");
                alert(value);   // smallFont blueColor
            }
        </script>
    </head>
    <body>
        <div id="xx" class="blueColor smallFont">안녕하세요</div>
        <button onclick="test8()">테스트1</button>
        <button onclick="test9()">테스트2</button>
    </body>
</html>


<br><br>
<br>

### 내용 컨트롤
---
```html
<html>
    <head>
        <meta charset="utf-8">
        <script>
            // innerText, innerHTML(사용금지)
            function test10() {
                var e = document.getElementById("xx1");

	        // 태그로 적용되는 것이아닌 그냥 일반 문자열로 적용됨
                e.innerText = "<div><p>반갑습니다<br>하하하<p></div>";
            }

            function test11() {
                var e = document.getElementById("xx2");

                // <div id="xx2">속에 실제로 태그가 적용됨(사용하지말것)
                // 1.코드가 지저분해짐 2.학습상 좋지 않음 but 내용 초기화할 때만 사용
                // <div id="xx2"><div><p>반갑습니다<br>하하하<p></div></div>
                e.innerHTML = "<div><p>반갑습니다<br>하하하<p></div>";

                // 박스 내부 내용 초기화
                // e.innerHTML = "";
            }
        </script>
    </head>
    <body>
        <div id="xx1">안녕하세요</div>
        <div id="xx2">안녕하세요</div>

        <button onclick="test10()">테스트1</button>
        <button onclick="test11()">테스트2</button>
    </body>
</html>
```

결과>

<html>
    <head>
        <meta charset="utf-8">
        <script>
            // innerText, innerHTML(사용금지)
            function test10() {
                var e = document.getElementById("xx1");

		// 태그로 적용되는 것이아닌 그냥 일반 문자열로 적용됨
                e.innerText = "<div><p>반갑습니다<br>하하하<p></div>";
            }

            function test11() {
                var e = document.getElementById("xx2");

                // <div id="xx2">속에 실제로 태그가 적용됨(사용하지말것)
                // 1.코드가 지저분해짐 2.학습상 좋지 않음 but 내용 초기화할 때만 사용
                // <div id="xx2"><div><p>반갑습니다<br>하하하<p></div></div>
                e.innerHTML = "<div><p>반갑습니다<br>하하하<p></div>";

                // 박스 내부 내용 초기화
                // e.innerHTML = "";
            }
        </script>
    </head>
    <body>
        <div id="xx1">안녕하세요</div>
        <div id="xx2">안녕하세요</div>

        <button onclick="test10()">테스트1</button>
        <button onclick="test11()">테스트2</button>
    </body>
</html>


<br>
<br><br>

### css 컨트롤(style 컨트롤)
---
```html
<html>
    <head>
        <meta charset="utf-8">
        <script>
            // css 스타일 컨트롤(setAttribute로 class 설정하는게 더 좋음)
            function test12() {
                var e = document.getElementById("xx3");

                // style.css의 속성들 = "문자열 값";
                e.style.backgroundColor = "red";    
            }

            function test13() {
                var e = document.getElementById("xx3");

                // 상대적인 크기의 단위(em)
                e.style.fontSize = "10em";
            }

            function test14() {
                var e = document.getElementById("xx3");
                e.style.color = "blue";
            }
        </script>
    </head>
    <body>
        <div id="xx3">안녕하세요</div>

        <button onclick="test12()">테스트1</button>
        <button onclick="test13()">테스트2</button>
        <button onclick="test14()">테스트3</button>
    </body>
</html>
```

결과>

<html>
    <head>
        <meta charset="utf-8">
        <script>
            // css 스타일 컨트롤(setAttribute로 class 설정하는게 더 좋음)
            function test12() {
                var e = document.getElementById("xx3");

                // style.css의 속성들 = "문자열 값";
                e.style.backgroundColor = "red";    
            }

            function test13() {
                var e = document.getElementById("xx3");

                // 상대적인 크기의 단위(em)
                e.style.fontSize = "10em";
            }

            function test14() {
                var e = document.getElementById("xx3");
                e.style.color = "blue";
            }
        </script>
    </head>
    <body>
        <div id="xx3">안녕하세요</div>

        <button onclick="test12()">테스트1</button>
        <button onclick="test13()">테스트2</button>
        <button onclick="test14()">테스트3</button>
    </body>
</html>


<br>
<br><br>

### 엘리먼트 생성과 삽입
---
```html
<html>
    <head>
        <meta charset="utf-8">
        <style>
            .blueFont {
                color: blue;
            }
        </style>
        <script>
            // 엘리먼트 생성과 삽입
            function test15() {
                // 엘리먼트 생성(매개변수는 태그명)
                var e = document.createElement("li");   //<li></li> 생성
                
                // 추가 컨트롤
                e.innerText = "qwer";
                e.style.color = "red";
                e.setAttribute("class", "blueFont");

                // 부모 엘리먼트 밑에 삽입
                var target = document.getElementById("xx4");
                target.appendChild(e);  // 부모의 자식 엘리먼트로 삽입
            }

            function test16() {
                // <li><p>안녕하세요</p><p>반갑습니다</p><button onclick="remove(this)">삭제버튼</button></li> 생성
                var li = document.createElement("li");
                var p1 = document.createElement("p");
                p1.innerText = "안녕하세요";
                // appendChild 순서가 중요(먼저 호출한 순서대로 붙음)
                li.appendChild(p1);
              
                var p2 = document.createElement("p");
                p2.innerText ="반갑습니다";
                li.appendChild(p2);     

                var p3 = document.createElement("button");
                p3.innerText = "삭제버튼";
                p3.setAttribute("onclick", "remove(this)");
                li.appendChild(p3);

                var xx4 = document.getElementById("xx4");
                xx4.appendChild(li);
            }

            function remove(e) {
                e.parentElement.remove();
            }
        </script>
    </head>
    <body>
        <ul id="xx4">
            <li>안녕하세요1</li>
            <li>안녕하세요2</li>
            <li>안녕하세요3</li>
            <li><p>안녕하세요</p><p>반갑습니다</p><button onclick="remove(this)">삭제버튼</button></li>
            <li>안녕하세요4</li>
            <li>안녕하세요5</li>
        </ul>

        <button onclick="test15()">테스트1</button>
        <button onclick="test16()">테스트2</button>
    </body>
</html>
```

결과>

<html>
    <head>
        <meta charset="utf-8">
        <style>
            .blueFont {
                color: blue;
            }
        </style>
        <script>
            // 엘리먼트 생성과 삽입
            function test15() {
                // 엘리먼트 생성(매개변수는 태그명)
                var e = document.createElement("li");   //<li></li> 생성
                
                // 추가 컨트롤
                e.innerText = "qwer";
                e.style.color = "red";
                e.setAttribute("class", "blueFont");

                // 부모 엘리먼트 밑에 삽입
                var target = document.getElementById("xx4");
                target.appendChild(e);  // 부모의 자식 엘리먼트로 삽입
            }

            function test16() {
                // <li><p>안녕하세요</p><p>반갑습니다</p><button onclick="remove(this)">삭제버튼</button></li> 생성
                var li = document.createElement("li");
                var p1 = document.createElement("p");
                p1.innerText = "안녕하세요";
                // appendChild 순서가 중요(먼저 호출한 순서대로 붙음)
                li.appendChild(p1);
              
                var p2 = document.createElement("p");
                p2.innerText ="반갑습니다";
                li.appendChild(p2);     

                var p3 = document.createElement("button");
                p3.innerText = "삭제버튼";
                p3.setAttribute("onclick", "remove(this)");
                li.appendChild(p3);

                var xx4 = document.getElementById("xx4");
                xx4.appendChild(li);
            }

            function remove(e) {
                e.parentElement.remove();
            }
        </script>
    </head>
    <body>
        <ul id="xx4">
            <li>안녕하세요1</li>
            <li>안녕하세요2</li>
            <li>안녕하세요3</li>
            <li><p>안녕하세요</p><p>반갑습니다</p><button onclick="remove(this)">삭제버튼</button></li>
            <li>안녕하세요4</li>
            <li>안녕하세요5</li>
        </ul>

        <button onclick="test15()">테스트1</button>
        <button onclick="test16()">테스트2</button>
    </body>
</html>




<br><br><br>

# 실습문제
---
**주어진 화면과 동일한 페이지를 작성하시오**
<br><br>
<a href="https://github.com/rib-president/Web-Study/blob/master/HTMLSpace/rubato.html" target="blank" style="font-size: 20px;">👉소스코드 Link</a>
<br>
<br>
> 예제

<img src="https://user-images.githubusercontent.com/57750308/147850064-c352d963-7561-4191-9b18-b9e8423cca82.png">

> 결과화면

<center><img src="https://user-images.githubusercontent.com/57750308/147849808-73847da8-8678-455b-9da4-3392f81c6450.PNG" width="700px"></center>

<br>
<br>
<br>
**주어진 화면을 토대로 게시판 페이지를 작성하시오**
<br><br>
<a href="https://github.com/rib-president/Web-Study/blob/master/HTMLSpace/board.html" target="blank" style="font-size: 20px;">👉소스코드 Link</a>
<br><br>
> 예제

<img src="https://user-images.githubusercontent.com/57750308/147850046-2ff029fa-e523-4024-be8c-3228df0c1c49.png">

> 결과화면

<img src="https://user-images.githubusercontent.com/57750308/147849961-5047dd36-8ead-4b26-bf5b-b9d3f59db5a7.png">

<br><br>


