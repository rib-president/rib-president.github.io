---
title: "8주차 SQL Study"
excerpt: "2021-12-13 ~ 2021-12-17"

toc: true
toc_sticky: true
categories:
  - Study
---
<br>
# ROWNUM
---
oracle에서 내부적으로 생성되는 가상 컬럼, table에 insert한 순번<br>

```sql
SELECT ROWNUM, custid, name, phone
FROM customer;

SELECT ROWNUM, book.*
FROM book;

SELECT ROWNUM "순번", custid, name, phone
FROM customer
WHERE ROWNUM <= 2;	--순번 <= 로는 안됨
```

> 출력 예시

<img src="https://user-images.githubusercontent.com/57750308/146630214-ddc4907c-e5a3-4686-8e18-167c31fa5ec6.png">


<br><br>
**book table에서 price가 가장 작은 2개의 책을 선택**
```sql
--1)ORDER BY 적용하여 오름차순으로 sorting
SELECT ROWNUM, book.*
FROM book
ORDER BY price;	--뒤에 WHERE절이 올 수 없어 price가 가장 작은 2개의 책을 선택 불가

--2)price로 ORDER BY된 인라인 뷰를 가져와 ROWNUM이 2보다 작은 튜플 조회
SELECT ROWNUM, b.*
FROM (SELECT * FROM book ORDER BY price) b
WHERE ROWNUM <= 2;
```

> 결과

<img src="https://user-images.githubusercontent.com/57750308/146630298-794a2671-6da8-4703-b4c0-d4ca9452f519.png">



<br><br>
`cf) ROWID : 테이블에서 행의 위치를 지정하는 논리적인 주소값`<br>


<br><br>

# DDL
---
Data Definition Language<br>
데이터 정의어로 CREATE, ALTER DROP 이 있음<br>
<br><br>

## CREATE
객체를 생성하는 명령어<br>
`CREATE TABLE 테이블명 (컬럼명 datatype(size) [constraint], ...);`<br>
<br>

* DataType
  * CHAR : 고정길이 문자(default 1byte)
    * 주어진 길이보다 작은 길이의 문자를 입력하더라도 고정된 길이를 가짐
  * VARCHAR2 : 가변길이 문자(default 1byte)
    * 주어진 길이보다 작은 길이의 문자를 입력하면 해당 길이로 크기가 변경
  * NUMBER([p, s]) : 가변숫자
    * p : 전체 유효 숫자 자릿수
    * s : 양수면 소수점 이하, 음수면 소수점 이상의 유효숫자 자릿수
  * DATE : 날짜형

```sql
--테이블 생성 예시
CREATE TABLE emp02 (
empno NUMBER(4),
ename VARCHAR2(20),
sal NUMBER(7, 2)
);
```

<br>
**AS를 이용한 TABLE 생성**
```sql
--SUBQUERY로 TABLE 생성(원본 테이블의 스키마와 데이터 전체 복사)
CREATE TABLE EMP01
AS
SELECT * FROM EMP;


--SUBQUERY로 특정 속성만 선택하여 TABLE 생성
CREATE TABLE EMP03
AS
SELECT EMPNO, ENAME FROM EMP;


--DEPTNO가 10인 튜플만 복사하여 생성
CREATE TABLE EMP05
AS
SELECT * FROM EMP
WHERE DEPTNO=10;
```
```sql
--SCHEMA는 복사하지만 데이터는 복사하지 않고 TABLE 생성
--1=0 : 항상 false -> 조건이 항상 일치하지 않아 선택되는 튜플이 없음
CREATE TABLE EMP06
AS
SELECT * FROM EMP WHERE 1=0;

SELECT * FROM EMP06;
```

> 결과

<img src="https://user-images.githubusercontent.com/57750308/146630417-819538fc-2516-478b-9505-1ef203c1877c.png">


<br><br>
<br>

## ALTER
객체의 구조를 변경하는 명령어<br>
ADD, MODIFY, DROP 등과 함께 사용<br>
`ALTER TABLE 테이블명 ADD/MODIFY/DROP 변경할 내용`<br>
<br><br>

* **ADD** 컬럼 추가
  * `ALTER TABLE emp02 ADD (job VARCHAR2(9));`
* **MODIFY** 컬럼 변경
  * 컬럼 데이터 타입, 길이, 기본값 등 변경
  * 컬럼에 데이터가 없는 경우
    * 데이터 타입, 길이 등 모두 변경 가능
  * 컬럼에 데이터가 있는 경우
    * 데이터 타입 변경 불가, 데이터 유실 방지를 위해 길이는 늘리는 것만 가능
  * job VARCHAR2(9) -> job VARCHAR2(30)으로 변경
    *  `ALTER TABLE emp02 MODIFY(job VARCHAR2(30));`
  * deptno를 기본키로 설정
    * `ALTER TABLE dept MODIFY(deptno NUMBER(2) PRIMARY KEY);`
* **DROP** 컬럼 삭제
  * `ALTER TABLE emp02 DROP COLUMN job;`
* SET UNUSED 컬럼 사용 제한
  * 효과는 비슷하지만 DROP보다 속도가 빠름
  * `ALTER TABLE emp01 SET UNUSED(job);`
  * SET UNUSED로 설정된 속성들 일괄 삭제
    * `ALTER TABLE emp01 DROP UNUSED COLUMNS;`

<br><br>

## DROP
객체를 삭제하는 명령어<br>
`DROP TABLE 테이블명;`<br>
<br><br>

## TRUNCATE
데이터를 제거하는 명령어<br>
`TRUNCATE TABLE 테이블명;`<br>
<br>
데이터를 제거한다는 면에서 DELETE와 같은 기능을 가졌지만 TRUNCATE 속도가 더 빠름<br>
`TRUNCATE TABLE emp01;`<br>
　　　vs<br>
`DELETE emp01;`<br>
<br><br>

**RENAME**
이름 변경<br>
`RENAME 이전테이블명 TO 바꿀테이블명;`

<br><br>
<br>

# DML(Data Manipulation Language)
---
INSERT(행추가), UPDATE(행수정), DELETE(행삭제, SELECT(조회)<br>
<br><br>

## INSERT
`INSERT INTO 테이블명(컬럼1, 컬럼2, ...) VALUES (값1, 값2);`
```sql
--특정 속성 선택하여 삽입(기입한 속성 순서, 타입, 개수에 맞게 VALUES 입력)
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUNTING', 'NEW YORK');

INSERT INTO DEPT01 (DNAME, DEPTNO, LOC)
VALUES ('HR', 20, 'BOSTON');

--전체 속성값 삽입(테이블 생성시 기입한 속성 순서, 타입, 개수에 맞게 VALUES 입력)
INSERT INTO DEPT01
VALUES (20, 'RESEARCH', 'DALLAS');

--속성값으로 NULL 입력하기
--LOC 속성에 값을 주지않음 -> null 값
INSERT INTO DEPT01 (DEPTNO, DNAME)
VALUES(40, 'OPERATIONS');

--LOC 속성에 NULL 값을 직접 입력하거나 '' 입력
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC)
VALUES (50, 'OP2', NULL);

INSERT INTO DEPT01 (DEPTNO, DNAME, LOC)
VALUES (60, 'OP3', '');

--서브쿼리로 데이터 삽입하기
INSERT INTO DEPT01
SELECT * FROM DEPT;

--SUBQUERY 사용하여 EMP TABLE의 DEPTNO가 10인 것만 INSERT
INSERT INTO EMP01
SELECT * FROM EMP WHERE DEPTNO = 10;
```

<br>
**INSERT ALL :** 다중 테이블에 다중행 입력
```sql
INSERT ALL
INTO EMP_HR VALUES (EMPNO, ENAME, HIREDATE)
INTO EMP_MGR VALUES (EMPNO, ENAME, MGR)
SELECT  EMPNO, ENAME, HIREDATE, MGR FROM EMP WHERE DEPTNO=20;

--WHEN~THEN 사용하여 입력되는 값에 조건 적용
INSERT ALL
WHEN HIREDATE > '1982/01/01' THEN
INTO EMP_HR02 VALUES(EMPNO, ENAME, HIREDATE)
WHEN SAL > 2000 THEN
INTO EMP_SAL VALUES(EMPNO, ENAME, SAL)
SELECT EMPNO, ENAME, HIREDATE, SAL FROM EMP;
```

<br>
<br><br>
## UPDATE
`UPDATE 테이블명 SET 변경할 속성 = 변경할 값;`
```sql
--DEPTNO 속성의 모든 값을 30으로 수정
UPDATE EMP01
SET DEPTNO = 30;

--모든 사원의 급여를 10% 인상
UPDATE EMP01
SET SAL = SAL * 1.1;

--모든 사원의 입사일자를 오늘로 수정
UPDATE EMP01
SET HIREDATE = SYSDATE;

--WHERE절 사용하여 특정 행만 수정
UPDATE EMP01
SET DEPTNO = 30
WHERE DEPTNO = 10;

--SAL이 3000이상인 사람만 10% 인상
UPDATE EMP01
SET SAL = SAL * 1.1
WHERE SAL >= 3000;

--83년 입사자만 입사일을 오늘로 변경
UPDATE EMP01
SET HIREDATE = SYSDATE
WHERE SUBSTR(HIREDATE, 1, 2) = '83';

--콤마(,)로 구분하여 여러개 UPDATE
--SCOTT 사원의 DEPTNO를 30으로 변경하고 JOB을 MANAGER로 변경
UPDATE EMP01
SET DEPTNO = 30, JOB = 'MANAGER'
WHERE ENAME = 'SCOTT';

--SUBQUERY를 사용하여 UPDATE
UPDATE DEPT01
SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 40)
WHERE DEPTNO = 20;
```

<br>
<br><br>

## DELETE
`DELETE [FROM] 테이블명;`
```sql
--모든 행 삭제
DELETE FROM DEPT01;

--부서코드가 30인 행만 삭제
DELETE FROM DEPT01 WHERE DEPTNO=30;

--커미션이 NULL이고 SAL이 1000이하인 행 삭제
DELETE FROM EMP01
WHERE COMM IS NULL AND SAL <= 1000;

--SUBQUERY를 사용하여 삭제
DELETE FROM EMP01
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');
```

<br><br>
<br>

# 트랜잭션(Transaction)
---
데이터 처리의 한 단위<br>
오라클에서 발생하는 여러개의 SQL 명령문들을 하나의 논리적인 작업단위로 처리<br>
<br>

> All-Or-Nothing 방식
>> 여러 개의 명령어 집합이 정상적으로 처리되면 정상종료, 하나라도 잘못되었다면 전체 취소<br>
>> => 데이터의 일관성 유지, 안정적으로 데이터 복구

<br>
**트랜잭션 제어 명령어 :** COMMIT, ROLLBACK, SAVEPOINT

<br><br>

## COMMIT
INSERT, UPDATE, DELETE 등 DML으로 수정된 테이블 행의 값들을 확정<br>
CREATE, ALTER, DROP 등 DDL은 실행과 동시에 내부적으로 COMMIT이 진행됨<br><br>
ROLLBACK이 되는 시점 -> COMMIT 이전으로 수정 불가<br>
`COMMIT;`<br>
<br><br>

## ROLLBACK
INSERT, UPDATE, DELETE 등 테이블의 수정된 행들을 DML 실행 전의 상태 or COMMIT 당시 상태로 원복<br>
CREATE, DROP, TRUNCATE, ALTER 등 DDL은 실행과 동시에 내부적으로 COMMIT -> ROLLBACK 안됨<br>
`ROLLBACK;`
<br>
```sql
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT;

SELECT * FROM DEPT01;	--4행 존재

DELETE FROM DEPT01;	--4행 삭제
	
SELECT * FROM DEPT01;	--0행 존재

ROLLBACK;		--맨 처음 CREATE 됐을 때로 ROLLBACK

SELECT * FROM DEPT01;	--4행 존재

DELETE FROM DEPT01 WHERE DEPTNO=20;	--DEPTNO가 20인 행 삭제

SELECT * FROM DEPT01;	--3행 존재

COMMIT;

INSERT INTO DEPT01 VALUES(50, 'TEST', 'SEOUL');

SELECT * FROM DEPT01;	--4행 존재

ROLLBACK;		--COMMIT 됐을 때로 ROLLBACK(3행 존재)
```

<br>
<br>
## SAVEPOINT
중간단계 저장<br>
`SAVEPOINT 별칭;`
<br>
```sql
DELETE FROM DEPT01 WHERE DEPTNO=40;

COMMIT;		--COMMIT을하면 COMMIT 이전의 SAVEPOINT는 사라짐

DELETE FROM DEPT01 WHERE DEPTNO=30;

SAVEPOINT C1;   --C1전의 데이터 임시 저장(임시 COMMIT)

DELETE FROM DEPT01 WHERE DEPTNO=20;

SAVEPOINT C2;

DELETE FROM DEPT01 WHERE DEPTNO=10;

ROLLBACK TO C2;		--SAVEPOINT C2로 ROLLBACK, DEPTNO 10 존재

ROLLBACK TO C1;		--SAVEPOINT C1로 ROLLBACK, DEPTNO 10,20 존재

ROLLBACK;		--COMMIT 시점으로 ROLLBACK, DEPTNO 10,20,30 존재
```

<br>
<br><br>

# 제약조건(Constraint)
---
데이터 무결성(Integrity) 유지 목적
1. 도메인 제약조건
- NOT NULL, UNIQUE, CHECK, DATE TYPE
2. 개체 무결성 제약조건
- PRIMARY KEY(NOT NULL, UNIQUE)
3. 참조 무결성 제약조건
- FOREIGN KEY

<br><br>

## NOT NULL
속성 값으로 NULL이 오는 것을 허용하지 않음
```sql
--EMP01 : EMPNO, ENAME에 대해 NOT NULL 제약조건 설정
CREATE TABLE EMP01(
    EMPNO NUMBER(4) NOT NULL,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2)
);

--에러발생
INSERT INTO EMP01
VALUES(NULL, NULL, 'SALESMANE', 10);	--cannot insert NULL into ("SCOTT"."EMP01"."EMPNO")
```

<br>
<br><br>

## UNIQUE
해당 속성에서 유일한 값만 존재해야함
```sql
CREATE TABLE EMP03(
    EMPNO NUMBER(4) UNIQUE,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2)
);

--현재 접속한 USER의 제약조건 조회
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

INSERT INTO EMP03
VALUES(7499, 'ALLEN', 'SALESMAN', 10);

--EMPNO에 중복 값 입력 시도
INSERT INTO EMP03
VALUES(7499, 'SCOTT', 'MANAGER', 20);	
/*unique constraint (SCOTT.SYS_C007074) violated
SYS_C007074 : 제약조건명(별도로 지정하지 않아 oracle에서 자동 부여된 이름)*/


--NULL은 중복으로 체크 안됨
INSERT INTO EMP03
VALUES(NULL, 'SCOTT', 'MANAGER', 20);


INSERT INTO EMP03
VALUES(NULL, 'JOHNS', 'ANALYST', 30);
```

<br>
<br><br>


## PRIMARY KEY(기본키)
대표가 되는 키<br>
NOT NULL, UNIQUE 제약 조건을 가짐
```sql
--DEPT 테이블의 DEPTNO는 PRIMARY KEY
--DEPTNO에 이미 10 존재하는 상황에서 중복 값을 넣는 경우
INSERT INTO DEPT
VALUES(10, 'TEST', 'SEOUL');
/*오류 보고 -
ORA-00001: unique constraint (SCOTT.SYS_C007036) violated*/


INSERT INTO DEPT
VALUES(NULL, 'TEST', 'SEOUL');
/*ORA-01400: cannot insert NULL into ("SCOTT"."DEPT"."DEPTNO")*/


--USER_CONSTRAINTS 데이터 딕셔너리뷰에서 제약조건 확인
--CONSTRAINT_TYPE : P(PRIMARY KEY), R(FOREIGN KEY), C(CHECK, NOT NULL), U(UNIQUE)
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT';
```

> DEPT TABLE의 제약조건 조회 결과

<img src="https://user-images.githubusercontent.com/57750308/146632008-73ba14f4-d7b3-4f31-b417-45514d15be05.png">

<br>
<br><br>


## FOREIGN KEY(외래키)
기본키를 참조하는 키, 부모키의 도메인에 해당하는 값만 가질 수 있음<br>
부모키에서 값이 삭제됨 -> 설정에 따라 외래키 데이터가 달라짐(동반 삭제, NULL로 변경 등)<br>
NULL, 중복 값 허용
```sql
--EMP의 DEPTNO는 FOREIGN KEY(REFERENCES DEPT(DEPTNO))
--DEPT.DEPTNO = {10, 20, 30, 40}
CREATE TABLE EMP06(
    EMPNO NUMBER(4) CONSTRAINT EMP06_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP06_ENAME_NN NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2) CONSTRAINT EMP06_DEPTNO_FK REFERENCES DEPT(DEPTNO)
);


----integrity constraint (SCOTT.EMP06_DEPTNO_FK) violated - parent key not found
INSERT INTO EMP06
VALUES(7566, 'SCOTT', 'MANAGER', 50);
```

<br>
<br><br>

## CHECK
입력되는 값을 체크하여 설정된 조건에 해당하는 값만 입력
```sql
CREATE TABLE EMP07(
    EMPNO NUMBER(4) CONSTRAINT EMP07_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP07_ENAME_NN NOT NULL,
    SAL NUMBER(7, 2) CONSTRAINT EMP07_SAL_CK CHECK(SAL BETWEEN 500 AND 5000),
    GENDER VARCHAR2(1) CONSTRAINT EMP07_GENDER_CK CHECK(GENDER IN('M', 'F'))
);

/*SAL 속성에는 500이상 5000이하의 값만 입력 가능*/
/*GENDER 속성에는 'M' 또는 'F' 만 입력 가능*/
INSERT INTO EMP07
VALUES(7699, 'MARY', 6000, 'F');	--check constraint (SCOTT.EMP07_SAL_CK) violated

INSERT INTO EMP07
VALUES(7899, 'QUEEN', 3300, 'Q');	--check constraint (SCOTT.EMP07_GENDER_CK) violated

--대소문자 구별
INSERT INTO EMP07
VALUES(7899, 'QUEEN', 3300, 'f');	--check constraint (SCOTT.EMP07_GENDER_CK) violated
```

<br>
<br><br>

## DEFAULT
해당 속성에 명시적으로 INSERT 되는 값이 없을 때 default 값이 들어감
```sql
CREATE TABLE DEPT01 (
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13) DEFAULT 'SEOUL'
);

--LOC 속성 제외하고 값 입력
INSERT INTO DEPT01 (DEPTNO, DNAME)
VALUES(10, 'ACCOUNTING');

SELECT * FROM DEPT01;	--LOC에 DEFULAT값인 'SEOUL' 자동 입력됨
```

> 결과

<img src="https://user-images.githubusercontent.com/57750308/146632331-6e3e63f8-bf40-47fc-923d-2fbb0d7380da.png">


<br>
<br><br>

## 제약조건 지정 방식
(1) 컬럼 레벨 제약조건 : 속성 옆에 기입<br><br>
(2) 테이블 레벨 제약 조건 : PRIMARY KEY, UNIQUE, FOREIGN KEY, CHECK만 가능(NOT NULL, DEFUALT 불가)

<br>
```sql
--테이블레벨 방식으로 CONSTRAINT 조건 지정하기
--(PRIMARY KEY, UNIQUE, FOREIGN KEY, CHECK만 가능(NOT NULL, DEFAULT 불가))
CREATE TABLE EMP02(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10) NOT NULL,		--NOT NULL은 테이블레벨로 지정X
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4),
    --TABEL LABEL CONSTRAINT 지정
    PRIMARY KEY(EMPNO),
    UNIQUE(JOB),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO)
);


--테이블레벨 방식으로 CONSTRAINT 이름+조건 지정하기
--(NOT NULL은 컬럼 레벨 방식으로 지정)
CREATE TABLE EMP03(
    EMPNO NUMBER(4) CONSTRAINT EMP03_ENAME_NN NOT NULL,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4),
    --TABLE LAVEL CONSTRAINT 지정
    CONSTRAINT EMP03_EMPNO_PK PRIMARY KEY(EMPNO),
    CONSTRAINT EMP03_JOB_UK UNIQUE(JOB),
    CONSTRAINT EMP03_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO)
);


--복합키를 기본키로 지정(테이블레벨 제약조건 사용)
--복합키로 지정된 NAME와 HPHONE의 값이 모두 동일해야만 중복
--('HI', 'BYE') == ('HI', 'BYE')
--('HI', 'BYE') != ('HI2', 'BYE')
--('HI', 'BYE') != ('HI', 'BYE2')
CREATE TABLE MEMBER01 (
    NAME VARCHAR2(10),
    HPHONE VARCHAR2(16),
    ADDRESS VARCHAR2(30),
    --복합키를 TABLE LEVEL로 CONSTRAINT 지정
    CONSTRAINT MEMBER01_COMBO_PK PRIMARY KEY(NAME, HPHONE)
);
```

> PK가 복합키인 MEMBER01의 제약조건 컬럼 조회

<img src="https://user-images.githubusercontent.com/57750308/146632676-7056dc16-69ae-4d72-96ea-be15ef0a7bb0.png">

<br>
```sql
--TABLE 생성 후 CONSTRAINT 추가하기(ALTER TABLE)
CREATE TABLE EMP01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4)
);


--기본키 추가(TABLE LEVEL에서 CONSTRAINT 추가)
ALTER TABLE EMP01
ADD CONSTRAINT EMP01_EMPNO_PK PRIMARY KEY(EMPNO);


--외래키 추가(TABLE LEVEL에서 CONSTRAINT 추가)
ALTER TABLE EMP01
ADD CONSTRAINT EMP01_DEPTNO_FK
FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO);


--NOT NULL추가(COLUMN LEVEL에서 CONSTRAINT 추가)
ALTER TABLE EMP01
MODIFY ENAME CONSTRAINT EMP01_ENAME_NN NOT NULL;


--TABLE에 설정된 CONSTRAINT 제거
--ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명
ALTER TABLE EMP05
DROP CONSTRAINT EMP05_EMPNO_PK;	--기본키 제약조건만 제거되고 데이터는 유지


--기본키 제약조건 삭제 후 EMPNO에 중복 값 입력 가능해짐
INSERT INTO EMP05
VALUES(7499, 'MARY', 'ANALYST', 20);


--NOT NULL 제약조건 삭제 후 ENAME에 NULL 입력 가능
ALTER TABLE EMP05
DROP CONSTRAINT EMP05_ENAME_NN;

INSERT INTO EMP05
VALUES(7566, NULL, 'CLERK', 30);
```

<br><br>

# 데이터베이스 객체
---

## 뷰(View)
물리적인 테이블을 근거로한 논리적인 가상 테이블<br><br>
기본 테이블에서 파생된 객체로 기본테이블에 대한 하나의 쿼리문<br>
=> 뷰 생성당시의 AS 이하 쿼리문을 저장하고 있음<br>

```sql
/*뷰 생성*/
CREATE VIEW EMP_VIEW30
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30;
--위의 SELECT ~~~ ; 가 EMP_VIEW30의 자리에 대체됨

--뷰 이름으로 조회
SELECT * FROM EMP_VIEW30;

--실제 실행되는 SQL문
SELECT * FROM (
SELECT EMPNO, ENAME, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30;)

--VIEW TABLE의 내부 구조 살펴보기
--TEXT : CREATE VIEW에서 AS 다음에 나오는 SUBQUERY로 VIEW가 사용될 때 뷰 이름에 대체되는 쿼리문
SELECT VIEW_NAME, TEXT FROM USER_VIEWS;
```

> USER_VIEWS 조회 결과

<img src="https://user-images.githubusercontent.com/57750308/146633174-8fe33c99-0101-435c-9da6-0f7579c061cd.png">

=> 실제로 VIEW TABLE의 원본 테이블을 사용하는 것<br>
=> INSERT, UPDATE, DELETE 등을 하면 실제 원본 테이블에 적용됨<br>

```sql
INSERT INTO EMP_VIEW30
VALUES (1111, 'AAAA', 30);

SELECT * FROM EMP_VIEW30;	-- (1111, 'AAAA', 30) 튜플 확인 가능

SELECT * FROM EMP_COPY;		--원본 테이블에 (1111, 'AAAA', 30) 튜플 저장됨
```

> EMP_COPY 조회 결과

<img src="https://user-images.githubusercontent.com/57750308/146633261-6651d006-42de-4904-929e-8d5d2e560ded.png">

<br>

**뷰 테이블 사용 이유**
* 자주 사용하는 SELECT문 간편화
  * SELECT문을 매번 타이핑하기보단 VIEW를 생성하는 것이 편리
* 보안상 좋음
  * 같은 테이블이더라도 사용자에 따라 뷰를 이용하여 보여지는 정보를 분리
  * ex) 회사 부서별로 테이블에 접근 가능한 정보 분류

<br><br>

**VIEW 컬럼에 ALIAS(별칭) 부여**
```sql
--별도로 컬럼명 부여하지 않으면 원본 테이블의 컬럼명을 따름
CREATE OR REPLACE VIEW EMP_VIEW (사원번호, 사원명, 급여, 부서번호)
AS
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP_COPY;

SELECT * FROM EMP_VIEW WHERE 부서번호=20;
```

> CREATE OR REPLACE
>> 객체가 없으면 CREATE, 있으면 새로운 객체로 REPLACE<br>
>> 삭제 후 재생성하는 경우 CREATE OR REPLACE를 사용하면 절차가 줄어듦

<br><br>

**VIEW 삭제**<br>
`DROP VIEW 뷰 이름;`<br>
<br><br>

**복합 VIEW(DML 사용 불가) 생성**
```sql
CREATE OR REPLACE VIEW EMP_VIEW_DEPT
AS
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO DESC;


--기존 VIEW에 SAL컬럼 추가(CREATE OR REPLACE 사용)
CREATE OR REPLACE VIEW EMP_VIEW_DEPT
AS
SELECT E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO DESC;
```

<br><br>

**WITH CHECK OPTION :** 뷰를 통해서 볼 수 있는 범위 내에서만 UPDATE/INSERT
```sql
--DEPTNO=30 조건인 뷰의 튜플을 DEPTNO=20으로 수정
UPDATE EMP_VIEW30 SET DEPTNO = 20 WHERE EMPNO=1111;

--DEPTNO=30이 조건이므로 위에 DEPTNO=20으로 수정한 튜플 안보임
SELECT * FROM EMP_VIEW30;	

--원본 테이블에서는 (1111, 'AAAA', 20) 튜플 보임
SELECT * FROM EMP_COPY;


/*WITH CHECK OPTION 적용*/
--뷰 생성
CREATE OR REPLACE VIEW VIEW_CHK30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
WHERE DEPTNO = 30 WITH CHECK OPTION;


UPDATE VIEW_CHK30
SET DEPTNO = 20
WHERE EMPNO = 7900;
/*view WITH CHECK OPTION where-clause violation 에러발생*/


INSERT INTO VIEW_CHK30
VALUES(1234, 'HI', 111, NULL, 20);
/*view WITH CHECK OPTION where-clause violation 에러발생*/
```

<br><br>


**WITH READ ONLY :** VIEW를 통해 기본 테이블 변경을 막음<br>
* VIEW는 원하는 정보 조회 용도
* VIEW를 통해 원본 테이블의 데이터 추가/수정/삭제하는 것은 불필요

```sql
/*WITH READ ONLY 적용된 뷰 생성*/
CREATE OR REPLACE VIEW VIEW_READ30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
WHERE DEPTNO = 30 WITH READ ONLY;

--데이터 수정 시도
UPDATE VIEW_READ30 SET COMM = 5000;
/*cannot perform a DML operation on a read-only view 에러발생*/


INSERT INTO VIEW_READ30
VALUES (1234, 'HIHI', 1, NULL, 30);
/*cannot perform a DML operation on a read-only view*/


DELETE FROM VIEW_READ30 WHERE DEPTNO = 30;
/*cannot perform a DML operation on a read-only view*/
```

<br><br>


**VIEW TABLE에서도 ROWNUM 사용가능**
```sql
CREATE OR REPLACE VIEW VIEW_HIRE
AS
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
ORDER BY HIREDATE;

SELECT ROWNUM, VIEW_HIRE.* FROM VIEW_HIRE;

--입사날짜가 가장 빠른 3명
SELECT * FROM VIEW_HIRE WHERE ROWNUM <= 3;
```

<br>
<br><br>

## SEQUENCE
일련번호 생성, INSERT 연산과 같이 사용되어 컬럼 값을 자동으로 발생시킴<br><br>

ex) `새로운 책을 등록할 때마다 BOOKID를 사람이 직접 지정해줘야함`<br>
`순차적으로 지정하지 못하거나 중복 번호 지정될 가능성이 있음 => BOOKID에 시퀀스 적용`
<br><br>


**SEQUENCE 객체 사용**
* NEXTVAL : 단위만큼 증가한 값
  * SELECT만해도 증가하므로 사용 유의
* CURRVAL : CURRENT VALUE(현재 값)

```sql
--SEQUENCE 생성하기
--10부터 시작해서 10씩 최대 100000까지 증가하는 시퀀스
--100000 도달 후 다시 START 값인 10부터 시작
CREATE SEQUENCE DEPT_DEPTNO_SEQ
INCREMENT BY 10
START WITH 10
MAXVALUE 100000
CYCLE;			


SELECT DEPT_DEPTNO_SEQ.NEXTVAL FROM DUAL;	--10

SELECT DEPT_DEPTNO_SEQ.CURRVAL FROM DUAL;	--10

SELECT DEPT_DEPTNO_SEQ.NEXTVAL FROM DUAL;	--20
SELECT DEPT_DEPTNO_SEQ.NEXTVAL FROM DUAL;	--30

SELECT DEPT_DEPTNO_SEQ.CURRVAL FROM DUAL;	--30
```

<br><br>
**테이블의 속성값으로 시퀀스 적용**
```sql
CREATE TABLE EMP01(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    HIREDATE DATE
);

INSERT INTO EMP01
VALUES(EMP_SEQ.NEXTVAL, 'JULIA', SYSDATE);		--(1, 'JULIA', '21/12/15')

INSERT INTO EMP01
VALUES(EMP_SEQ.NEXTVAL, 'MARY', SYSDATE);		--(2, 'MARY', '21/12/15')

INSERT INTO EMP01
VALUES(EMP_SEQ.NEXTVAL, 'ROBERT', SYSDATE);		--(3, 'ROBERT', '21/12/15')

--SEQUENCE 삭제
DROP SEQUENCE DEPT_DEPTNO_SEQ;
```

<br>
<br>

## INDEX
검색 속도를 빠르게 하려는 목적, B-tree 구조<br>
<br>
다만, 원래 데이터 외의 부가정보(트리에 필요한 데이터)가 필요 -> 많은 용량<br>
인덱스가 설정된 컬럼에 수정이 생기면 인덱스의 재구성이 발생(변경작업 빈번할수록 성능 저하)<br>
<br>

**현재 계정 소유의 테이블에 설정된 인덱스 조회**<br>
```sql
--테이블의 PRIMARY KEY로 설정된 컬럼은 기본적으로 INDEX가 설정되어 있음
SELECT INDEX_NAME, TABLE_NAME, COLUMN_NAME
FROM USER_IND_COLUMNS
WHERE TABLE_NAME IN ('EMP', 'DEPT');
```

> 결과

<img src="https://user-images.githubusercontent.com/57750308/146634175-d8005d0f-7279-4429-a042-eb591f4e1632.png">


<br>
**INDEX 사용**
```sql
--INDEX 생성(ENAME에 설정)
CREATE INDEX IDX_EMP01_ENAME
ON EMP01(ENAME);

--생성한 INDEX를 사용하는 곳은 SELECT 명령어의 WHERE 조건절 내부에서 주로 사용(빠르기 때문)
SET TIMING ON;	--시간 체크하는 명령어
SELECT DISTINCT EMPNO, ENAME
FROM EMP01
WHERE ENAME='SYJ';

--INDEX 삭제하기
DROP INDEX IDX_EMP01_ENAME;
```

<br>


|**인덱스를 사용해야하는 경우**|**인덱스를 사용하면 안되는 경우**|
|:----------------------:|:-------------------------:|
|테이블의 행의 수가 많을 때|행의 수가 적을 때|
|WHERE문에 해당 컬럼이 많이 사용될 때|해당 컬럼이 WHERE문에 많이 사용안될 때|
|검색 결과가 전체 데이터의 2~4% 정도일 때|검색 결과가 전체 데이터의 10~15% 이상일 때|
|JOIN에 자주 사용되는 컬럼이나 NULL을 포함하는 컬럼이 많은 경우|입력/수정/삭제가 빈번|


<br>
<br><br>

# 정보보안(Infomation Security)
---
1. **Authentication**
- 시스템 사용자 인증, login ID와 password로 관리
2. **Authorization**
- 시스템 사용 권한, 사용자마다 시스템을 사용할 수 있는 권한이 다름

<br>
**Authentication**
```sql
--conn sys
--Table Space 생성하기(system 계정에서 가능)
/*Table Space : 오라클에서 데이터를 저장할 때 사용하는 논리적 저장공간
(하드디스크에서는 실제 여러개의 물리적인 데이터 파일로 구성될 수 있음)
오라클 시스템 운영에 필요한 필수 정보를 담고 있음*/
CREATE TABLESPACE md_tbs
DATAFILE 'C:\oraclexe\app\oracle\oradata\XE\md_tbs_data01.dbf'
size 10M;


--table space 삭제
/*DROP TABLESPACE md_test
INCLUDING CONTENTS AND DATAFILES;	--실제 dbf 파일까지 삭제(생략하면 dbf 파일은 저장장치에 남아있음)*/	


--USER 생성
CREATE USER mdguest
IDENTIFIED BY mdguest;	--password
/*별도 tablespace 지정을하지 않았다면 oracle 기본 tablespace인 users로 지정됨*/


CREATE USER mdguest2
IDENTIFIED BY mdguest2
DEFAULT TABLESPACE md_tbs;	--tablespace를 md_tbs로 지정
```

<br><br>

## DCL(Data Control Language)
소유한 객체에 대한 사용 권한을 관리하기 위한 명령, GRANT(권한 허가)/REVOKE(권한 철회)
<br><br>


**GRANT**
```sql
--conn sys
--USER에 권한 부여
--CONNECT : 해당 USER로 접속할 수 있는 권한
--RESOURCE : 객체 생성/수정/삭제, 데이터 입력/수정/조회/삭제 권한
GRANT CONNECT, RESOURCE TO mdguest;
GRANT CONNECT, RESOURCE TO mdguest2;
```
```sql
--conn madang
--madang 소유의 BOOK 테이블을 SELECT할 수 있는 권한을 mdguest에게 부여
GRANT SELECT ON BOOK TO mdguest;


--madang 소유의 CUSTOMER 테이블을 SELECT, UPDATE할 수 있는 권한을 mdguest에게 부여
GRANT SELECT, UPDATE ON CUSTOMER TO mdguest
WITH GRANT OPTION;	--다른 사람에게 부여한 권한을 또 다른 사람에게 줄 수 있는 옵션(권한 재부여)
/*mdguest는 또 다른 USER에게 CUSTOMER 테이블의 SELECT, UPDATE 권한을 줄 수 있음*/


--모든 사용자에게 orders 테이블 SELECT할 수 있는 권한 부여
GRANT SELECT ON orders TO PUBLIC;
```
```sql
--conn mdguest
--mdguest에서 부여받은 권한으로 madang의 book, customer 테이블 조회 가능
SELECT * FROM madang.book;
SELECT * FROM madang.customer;
SELECT * FROM madang.orders;


--권한재부여
GRANT SELECT ON madang.customer TO mdguest2;	--성공(WITH GRANT OPTION)

GRANT SELECT ON madang.book TO mdguest2;	--insufficient privileges 에러(book 테이블은 권한 재부여 불가)
```
```sql
--conn mdguest2
--mdguest에서 부여받은 권한으로 madang의 customer 테이블 조회 가능
SELECT * FROM madang.customer;

--madang에게 부여받은 권한으로 madang의 orders 테이블 조회 가능
SELECT * FROM madang.orders;
```

<br>
<br>
**REVOKE**
```sql
--conn madang
REVOKE SELECT ON book FROM mdguest;

REVOKE SELECT ON customer FROM mdguest;	--mdguest가 mdguest2에게 재부여한 권한까지 철회

--conn mdguest
SELECT * FROM madang.book;	--table or view does not exist
SELECT * FROM madang.customer;	--table or view does not exist

--conn mdguest2
SELECT * FROM madang.customer;	--table or view does not exist
```

<br><br>

## ROLE
권한을 GROUPING, 각 사용자별로 권한 부여 작업을 최소화<br>
ROLE 생성은 sys 또는 system 계정에서만 가능<br>
<br>
```sql
--conn system
--ROLE 생성
CREATE ROLE programmer;


--ROLE에 권한부여(테이블 생성, 뷰 생성)
--어떠한 테이블이나 뷰 생성가능한 권한
GRANT CREATE ANY TABLE, CREATE ANY VIEW TO programmer;

--mdguest2.NEWTABLE을 SELECT, INSERT할 수 있는 권한
GRANT SELECT, INSERT ON mdguest2.NEWTABLE TO programmer;


--사용자에게 ROLE 부여
GRANT programmer TO mdguest;

SET ROLL ALL;	--접속되어있는 사용자에게 역할 활성화
```
```sql
--conn mdguest
--부여받은 롤 사용
--다른 계정 소속의 table 생성 가능(CREATE ANY TABLE)
CREATE TABLE mdguest2.NEWTABLE (
    myname VARCHAR2(40),
    myphone VARCHAR2(20)
);


INSERT INTO mdguest2.NEWTABLE
VALUES ('홍길동', '000-000-0100');
/*mdguest에서 mdguest2.NEWTABLE에 INSERT한 튜플은 mdguest2에서는 보이지 않음
=> mdguest에서 COMMIT해야 보임*/
```
```sql
--conn sys
--ROLE 삭제 => mdguest가 ROLE과 함께 부여받았던 권한들도 철회됨
DROP ROLE programmer;
```

<br>
<br><br>

# PL/SQL
---
SQL에 절차적 프로그래밍 언어를 가미<br>
(Oracle's Procedural Language extension to SQL)<br>
<br>

* SQL 명령어를 사용하여 if/while 제어문, 변수 선언 등 코딩할 수 있음
* PASCAL과 유사한 구조로 DECLARE~BEGIN~EXCEPTION~END 순서를 가짐
* 블록 구조의 언어로 크게 세 부분(선언부/실행부/예외처리부)으로 나뉨


<br><br>

## 기본 문법
**HELLO, PLSQL 출력**
```sql
--Oracle PL/SQL로 짠 프로그램 결과 값을 console에 출력하라는 설정
SET SERVEROUTPUT ON	

BEGIN
    DBMS_OUTPUT.PUT_LINE('HELLO, PLSQL');		
END;
/
/* 슬래시(/) : PL/SQL 프로그램이 종료된다는 것을 알리는 기호 */
```

<br>

> PL/SQL문 실행 @ 키워드 사용
>> @C:\DevSpace\DBSpace\PLSQLEx01.sql

<br>
**변수 선언하고 사용하기**
```sql
DECLARE
    VEMPNO NUMBER(4);
    VENAME VARCHAR2(10);
BEGIN
    VEMPNO := 7788;
    VENAME := 'SCOTT';
    DBMS_OUTPUT.PUT_LINE('사번    /   이름');
    DBMS_OUTPUT.PUT_LINE('------------------');
    DBMS_OUTPUT.PUT_LINE(VEMPNO || ' / ' || VENAME);		--7788 / SCOTT
END;
/
```

<br>
**SELECT 문을 이용하여 EMP 테이블 내 사번과 이름 검색하기**
```sql
DECLARE
    --VEMPNO의 타입을 EMP.EMPNO의 타입(NUMBER(4))으로 선언
    VEMPNO EMP.EMPNO%TYPE;	
    VENAME EMP.ENAME%TYPE;
BEGIN
    DBMS_OUTPUT.PUT_LINE('사번    /   이름');
    DBMS_OUTPUT.PUT_LINE('------------------');
    SELECT EMPNO, ENAME INTO VEMPNO, VENAME
        FROM EMP
        WHERE ENAME = 'SCOTT';
    DBMS_OUTPUT.PUT_LINE(VEMPNO || ' / ' || VENAME);		--7788 / SCOTT
END;
/
```

<br>
**테이블 타입(1차원 배열)과 for문 사용**
```sql
SET SERVEROUTPUT ON
DECLARE
    --테이블 타입을 선언
    --원소의 타입은 EMP.ENAME의 타입인 VARCHAR2(10)
    --INDEX BY BINARY_INTEGER : 인덱스 값이 integer
    TYPE ENAME_TABLE_TYPE IS TABLE OF EMP.ENAME%TYPE INDEX BY BINARY_INTEGER;
    TYPE JOB_TABLE_TYPE IS TABLE OF EMP.JOB%TYPE INDEX BY BINARY_INTEGER;
    
    ENAME_TABLE ENAME_TABLE_TYPE;
    JOB_TABLE JOB_TABLE_TYPE;
    I BINARY_INTEGER := 0;
BEGIN
    --EMP 테이블에서 사원명과 직급을 얻어옴
    FOR K IN (SELECT ENAME, JOB FROM EMP) LOOP
        I := I + 1;
        ENAME_TABLE(I) := K.ENAME;
        JOB_TABLE(I) := K.JOB;
    END LOOP;
    
    --테이블 변수에 저장된 값 출력
    FOR J IN 1..I LOOP
        DBMS_OUTPUT.PUT_LINE(RPAD(ENAME_TABLE(J), 12) || ' / ' || RPAD(JOB_TABLE(J), 9));
    END LOOP;
END;
/
```

<br>
**레코드 타입(C의 구조체) 사용**
```sql
SET SERVEROUTPUT ON
DECLARE
    --레코드 타입(C에서의 구조체) 선언
    TYPE EMP_RECORD_TYPE IS RECORD(
        V_EMPNO EMP.EMPNO%TYPE,
        V_ENAME EMP.ENAME%TYPE,
        V_JOB   EMP.JOB%TYPE,
        V_DEPTNO EMP.DEPTNO%TYPE
    );
    EMP_RECORD EMP_RECORD_TYPE;
BEGIN
    SELECT EMPNO, ENAME, JOB, DEPTNO INTO EMP_RECORD
        FROM EMP
        WHERE ENAME=UPPER('SCOTT');
    DBMS_OUTPUT.PUT_LINE('사원번호 : ' || TO_CHAR(EMP_RECORD.V_EMPNO));
    DBMS_OUTPUT.PUT_LINE('이   름 : ' || EMP_RECORD.V_ENAME);
    DBMS_OUTPUT.PUT_LINE('담당업무 : ' || EMP_RECORD.V_JOB);
    DBMS_OUTPUT.PUT_LINE('부서번호 : ' || TO_CHAR(EMP_RECORD.V_DEPTNO));
END;
/
```

<br>
**if문 사용**
```sql
SET SERVEROUTPUT ON
DECLARE
    VEMPNO NUMBER(4);
    VENAME VARCHAR2(20);
    VDEPTNO EMP.DEPTNO%TYPE;
    VDNAME VARCHAR2(20) := NULL;
BEGIN
    SELECT EMPNO, ENAME, DEPTNO INTO VEMPNO, VENAME, VDEPTNO
        FROM EMP
        WHERE EMPNO = 7788;
    IF (VDEPTNO = 10) THEN
        VDNAME := 'ACCOUNTING';
    END IF;
    IF (VDEPTNO = 20) THEN
        VDNAME := 'RESEARCH';
    END IF;
    IF (VDEPTNO = 30) THEN
        VDNAME := 'SALES';
    END IF;
    IF (VDEPTNO = 40) THEN
        VDNAME := 'OPERATIONS';
    END IF;
    DBMS_OUTPUT.PUT_LINE('사번    이름   부서명');
    DBMS_OUTPUT.PUT_LINE(VEMPNO || '   ' || VENAME || '   ' || VDNAME);   
END;
/
```

<br>
**if~elsif~else 사용**
```sql
SET SERVEROUTPUT ON
DECLARE
    VEMPNO NUMBER(4);
    VENAME VARCHAR2(20);
    VDEPTNO EMP.DEPTNO%TYPE;
    VDNAME VARCHAR2(20) := NULL;
BEGIN
    SELECT EMPNO, ENAME, DEPTNO INTO VEMPNO, VENAME, VDEPTNO
        FROM EMP
        WHERE EMPNO = 7788;
    IF (VDEPTNO = 10) THEN
        VDNAME := 'ACCOUNTING';
    ELSIF (VDEPTNO = 20) THEN
        VDNAME := 'RESEARCH';
    ELSIF (VDEPTNO = 30) THEN
        VDNAME := 'SALES';
    ELSE
        VDNAME := 'OPERATIONS';
    END IF;
    DBMS_OUTPUT.PUT_LINE('사번    이름   부서명');
    DBMS_OUTPUT.PUT_LINE(VEMPNO || '   ' || VENAME || '   ' || VDNAME);   
END;
/
```

<br>
**while문 사용**
```sql
SET SERVEROUTPUT ON
DECLARE
    N NUMBER := 1;
BEGIN
    WHILE N <= 5 LOOP
        DBMS_OUTPUT.PUT_LINE(N);
        N := N + 1;
    END LOOP;
END;
/
```

<br>
<br><br>
## 프로시저
return type이 void인 method<br>
<br>

**매개변수가 없는 프로시저**
```sql
--procedure01.sql
CREATE OR REPLACE PROCEDURE DEL_ALL
IS
--local variable declaration area
BEGIN
    DELETE FROM EMP01;
END;
/
```
```sql
--프로시저실행.sql
CREATE TABLE EMP01
AS
SELECT * FROM EMP;

SELECT * FROM EMP01;

--PROCEDURE를 데이터베이스에 저장하는 명령어(컴파일)
@C:\DevSpace\DBSpace\procedure01.sql;

--저장된 프로시저(stored procedure) 실행
EXECUTE DEL_ALL;

SELECT * FROM EMP01;	--EMP01의 데이터 전부 삭제됨


SELECT NAME, TEXT FROM USER_SOURCE;	--프로시저 이름과 선언시 사용된 문장 조회

--프로시저삭제
--DROP PROCEDURE 프로시저이름
```

<br>
**매개변수가 있는 프로시저**
```sql
--procedure02.sql
CREATE OR REPLACE PROCEDURE DEL_ENAME(VENAME EMP01.ENAME%TYPE)
IS
BEGIN
    DELETE FROM EMP01
    WHERE ENAME = VENAME;
END;
/
```
```sql
--프로시저실행.sql
DROP TABLE EMP01;

CREATE TABLE EMP01
AS
SELECT * FROM EMP;

SELECT * FROM EMP01;

@C:\DevSpace\DBSpace\procedure02.sql;

EXECUTE DEL_ENAME('SMITH');

SELECT * FROM EMP01;	--ENAME이 SMITH인 튜플 삭제됨
```

<br>
**값을 내보내는 프로시저**
```sql
--procedure03.sql
CREATE OR REPLACE PROCEDURE SEL_EMPNO
    (
        --IN : 내부적으로 사용, OUT : 프로시저 밖으로 내보냄(프로시저 밖에서 사용가능)
        VEMPNO IN EMP.EMPNO%TYPE,
        VENAME OUT EMP.ENAME%TYPE,
        VSAL OUT EMP.SAL%TYPE,
        VJOB OUT EMP.JOB%TYPE
    )
IS
BEGIN
    SELECT ENAME, SAL, JOB INTO VENAME, VSAL, VJOB
    FROM EMP
    WHERE EMPNO = VEMPNO;
END;
/
```
```sql
--프로시저실행.sql
@C:\DevSpace\DBSpace\procedure03.sql;

--변수선언
VARIABLE VAR_ENAME VARCHAR2(15);
VARIABLE VAR_SAL NUMBER;
VARIABLE VAR_JOB VARCHAR2(9);

--OUT 키워드가 있는 프로시저의 변수로부터 값을 받아옴
EXECUTE SEL_EMPNO(7788, :VAR_ENAME, :VAR_SAL, :VAR_JOB);

PRINT VAR_ENAME;
/*VAR_ENAME
--------------------------------------------------------------------------------
SCOTT*/

PRINT VAR_SAL;
/*   VAR_SAL
----------
      3000*/

PRINT VAR_JOB;
/*VAR_JOB
--------------------------------------------------------------------------------
ANALYST*/
```

<br>
<br><br>

## 함수
return값이 있는 method<br>
<br>

```sql
--function01.sql
CREATE OR REPLACE FUNCTION CAL_BONUS (VEMPNO IN EMP.EMPNO%TYPE)
    RETURN NUMBER
IS
    VSAL NUMBER(7, 2);
BEGIN
    SELECT SAL INTO VSAL
        FROM EMP
        WHERE EMPNO = VEMPNO;
    RETURN (VSAL * 2);
END;
/
```
```sql
--함수실행.sql
@C:\DevSpace\DBSpace\function01.sql;

VARIABLE VAR_RES NUMBER;

--함수에서 return한 값을 받아옴
EXECUTE :VAR_RES := CAL_BONUS(7788);

PRINT VAR_RES;
/*   VAR_RES
----------
      6000*/

--SELECT문에서 선언된 함수 사용 가능
SELECT SAL, CAL_BONUS(7788)
FROM EMP
WHERE EMPNO=7788;
```

<br>
<br><br>
# JDBC(Java Database Connectivity)
---
Oracle과 Java 연동에 필요한 Interface<br>
<br>
DBMS 마다 JDBC를 구현한 library(classes)를 제공<br>
=> 본인 DBMS 환경과 맞는 JDBC library 사용해야함<br><br>



## 정적인 쿼리문 처리
String 객체에 사용할 쿼리문을 그대로 입력<br>
`String query = "SELECT * FROM TABLENAME";`<br>
<br>
정적인 쿼리문을 처리하는 Statement 객체에 넣어 execute<br>
`Connection con;`<br>
`Statement stmt = con.createStatement();`<br>
`ResultSet rs = stmt.executeQuery(query);`<br>


```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class BookListEx01 {
	Connection con;
	
	public BookListEx01() {
		// Oracle Database와 연결(DBMS 종류마다 url 다름)
		// jdbc:oracle:thin은 사용하는 JDBC드라이버가 thin 타입을 의미, 자바용 오라클
		// localhost : 로컬과 연결, 1521 : 리스너 포트번호
		// xe : 리스너, oracle instance(oracle 설치할 때 default로 xe 설정됨)
		String url = "jdbc:oracle:thin:@localhost:1521:xe";
		String userid = "madang";
		String pwd = "madang";
		
		try {
			// JDBC 드라이버가 잘 설치됐는지 확인(DBMS 종류마다 클래스명 다름)
			Class.forName("oracle.jdbc.driver.OracleDriver");
			System.out.println("driver is loaded successfully");
		} catch (ClassNotFoundException e) {
			System.out.println("driver is load failure!");
		}
		

		try {
			// DBMS와 연결
			System.out.println("DBMS와 connection을 수행");
			con = DriverManager.getConnection(url, userid, pwd);
		} catch (SQLException e) {
			System.out.println("database connection failure");
		}
	}
	
	private void sqlRun() {
		// DBMS 종류마다 문법 다름
		String query = "SELECT * FROM book";
		
		try {
			// Statement 객체 : 정적인 쿼리문(쿼리문에 값이 미리 입력됨) 처리
			// DB에 SQL statements sending하는 statement 객체 생성
			Statement stmt = con.createStatement();

			//executeQuery : 주어진 SQL statement 실행
			// ResultSet : 복수개의 튜플을 담을 수 있는 class type
			ResultSet rs = stmt.executeQuery(query);
			System.out.println(" BOOK NO\tBOOK NAME\t\tPUBLISHER\tPRICE");

			// rs.next() : 현재 cusor를 다음으로 이동시켜 다음 tuple을 가리킴
			while(rs.next()) {
				// 주어진 idx의 컬럼에서 Integer/String 값을 가져옴
				// idx대신 컬럼명으로 줘도됨 getInt("price")
				System.out.print("\t" + rs.getInt(1));
				System.out.print("\t" + rs.getString(2));
				System.out.print("\t\t" + rs.getString(3));
				System.out.print("\t" + rs.getInt(4));
				System.out.println();
			}
			stmt.close();
			con.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
		BookListEx01 so = new BookListEx01();
		
		so.sqlRun();		
	}
}
```

<br><br>

## 동적인 쿼리문 처리
유동적인 속성 값의 자리에 ? 입력하여 쿼리문 작성<br>
`String query = "SELECT * FROM TABLENAME WHERE COL1 = ? AND COL2 = ?"`<br>
<br>
동적인 쿼리문을 처리하는 PreparedStatement 객체에 쿼리문 적용<br>
`Connection con;`<br>
`PreparedStatement pstmt = con.prepareStatement(query);`<br>
<br>
?의 값 채움(인덱스는 1부터 시작)<br>
`pstmt.setInt(1, 10);`<br>
`pstmt.setString(2, "Hello");`<br>
<br>
수행 결과로 ResultSet 객체의 값을 반환(SELECT문 수행할 때 사용)<br>
`ResultSet rs = pstmt.executeQuery();`<br>
<br>
`cf) int n = pstmt.executeUpdate();	// 반영된 레코드의 건수를 반환, 0이면 실패`<br>


```java
public class Employee {
	private int emplid;
	private String name;
	private String password;
	private String emailaddr;
	private String socialno;
	private String dept;
	private String adminyn;
	
	
	public Employee() {
		
	}
	
	public Employee(int emplid, String name, String password, String emailaddr, String socialno, String dept,
			String adminyn) {
		this.emplid = emplid;
		this.name = name;
		this.password = password;
		this.emailaddr = emailaddr;
		this.socialno = socialno;
		this.dept = dept;
		this.adminyn = adminyn;
	}

	// getter, setter methods ...
}
```
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;


public class EmployeeDB {
	Connection con;
	
	public EmployeeDB() {
		String driver = "oracle.jdbc.driver.OracleDriver";
		String url = "jdbc:oracle:thin:@localhost:1521:xe";
		String userid = "madang";
		String passwd = "madang";
		
		try {
			Class.forName(driver);
		} catch (Exception e) {
			System.out.println("driver load failure!");
//			e.printStackTrace();
		}
		
		try {
			con = DriverManager.getConnection(url, userid, passwd);
		} catch (SQLException e) {
			System.out.println("Oracle database connection failure");
//			e.printStackTrace();
		}
	}

	public Boolean employeeExist (String emplid, String password) {
		Boolean result = false;
		
		try {
			String query = "SELECT * FROM EMPLOYEE WHERE emplid = ? AND password = ? ";

			// prepareStatement : 동적인 쿼리문 처리
			PreparedStatement pstmt = con.prepareStatement(query);
			pstmt.setInt(1, Integer.parseInt(emplid));
			pstmt.setString(2, password);
			ResultSet rs = pstmt.executeQuery();
			
//			if (rs.next() == false) System.out.println("search is null");
//			else System.out.println("search result is true");
			
			while (rs.next()) {
				if ((Integer.toString(rs.getInt(1))).equals(emplid) && ((rs.getString(3)).equals(password))) {
					result = true;
					break;
				}
			}
			rs.close();
			pstmt.close();
		} catch (SQLException e) {
//			e.printStackTrace();
			System.out.println("employee search error");
		}
		return result;
	}
	
	public boolean employeeInsert (Employee empl) {
		
		try {
			String query = "insert into employee (emplid, name, password, emailaddr, socialno, dept, adminyn) " + 
					" values ( ?, ?, ?, ?, ?, ?, ? )";
			PreparedStatement pstmt = con.prepareStatement(query);
			
			pstmt.setInt(1, empl.getEmplid());
			pstmt.setString(2, empl.getName());
			pstmt.setString(3, empl.getPassword());
			pstmt.setString(4, empl.getEmailaddr());
			pstmt.setString(5, empl.getSocialno());
			pstmt.setString(6, empl.getDept());
			pstmt.setString(7, empl.getAdminyn());
			int n = pstmt.executeUpdate();

			// insert문 실행 성공
			if (n != 0) {
				pstmt.close();
				return true;
			}
			// insert문 실행 에러
			else return false;
		} catch (SQLException e) {
//			e.printStackTrace();
			System.out.println("employee insert error");
		}
		return false;
	}
	
	
	public boolean employeeUpdate (Employee empl) {
		
		try {
			String query = "UPDATE employee SET name =?, password=?, emailaddr=?, socialno=?, dept=?, adminyn=?"
								+ "	WHERE emplid = ?";
			PreparedStatement pstmt = con.prepareStatement(query);
			
			pstmt.setString(1, empl.getName());
			pstmt.setString(2, empl.getPassword());
			pstmt.setString(3, empl.getEmailaddr());
			pstmt.setString(4, empl.getSocialno());
			pstmt.setString(5, empl.getDept());
			pstmt.setString(6, empl.getAdminyn());
			pstmt.setInt(7, empl.getEmplid());
			int n = pstmt.executeUpdate();

			if (n != 0) {
				pstmt.close();
				return true;
			}
			else return false;
		} catch (SQLException e) {
//			e.printStackTrace();
			System.out.println("employee insert error");
		}
		return false;
	}

	
	public boolean employeeDelete (String emplid) {
		
		try {
			String query = "DELETE FROM employee WHERE emplid = ?";
//			String query = "UPDATE employee SET adminyn = 'N' WHERE emplid = ?";
			PreparedStatement pstmt = con.prepareStatement(query);
			
			pstmt.setInt(1, Integer.parseInt(emplid));
			int n = pstmt.executeUpdate();

			if (n != 0) {
				pstmt.close();
				return true;
			}
			else return false;
		} catch (SQLException e) {
//			e.printStackTrace();
			System.out.println("employee insert error");
		}
		return false;
	}	
	
	
	public ArrayList<Employee> employeeSearch (String searchText, int cond) {
		ArrayList<Employee> list = new ArrayList<Employee>();
		
		try {
			String dbRowId;
			if (cond == 0) dbRowId = "emplid";
			else if (cond == 1) dbRowId = "name";
			else return null;
			
			String query = "SELECT * FROM employee WHERE " + dbRowId + "= ?";
			PreparedStatement pstmt = con.prepareStatement(query);
			
			if (cond == 0) 
				pstmt.setInt(1, Integer.parseInt(searchText));	// employee id으로 검색
			else if (cond == 1) 
				pstmt.setString(1, searchText);			// employee name으로 검색

			ResultSet rs = pstmt.executeQuery();

			while (rs.next()) {
				Employee empl = new Employee();
				empl.setEmplid(rs.getInt("emplid"));
				empl.setName(rs.getString("name"));
				empl.setPassword(rs.getString("password"));
				empl.setEmailaddr(rs.getString("emailaddr"));
				empl.setSocialno(rs.getString("socialno"));
				empl.setDept(rs.getString("dept"));
				empl.setAdminyn(rs.getString("adminyn"));
				list.add(empl);
			}

		} catch (SQLException e) {
//			e.printStackTrace();
			System.out.println("employee insert error");
		}
		return list;
	}	
	
	
	public void close() {
		
		try {
			con.close();
		} catch (SQLException e) {
//			e.printStackTrace();
			System.out.println("connection close error");
		}
	}
	
}
```
```java
import java.util.ArrayList;
import java.util.List;

public class EmployeeEx {

	public static void main(String[] args) {
		
		EmployeeDB empDb = new EmployeeDB();
		Boolean check;
		List<Employee> list = new ArrayList<Employee>();
		
		if ( empDb.employeeExist("111111", "abcd") ) {
			System.out.println("조회한 employee가 존재합니다.");
		} else {
			System.out.println("조회한 employee가 테이블에 존재하지 않습니다.");
		}
		
		Employee empl = new Employee(77777, "최한나", "abcd", 
				"rrr@chat.com", "990221-202213", "영업", "N");
		check = empDb.employeeInsert(empl);
		
		if (check) {
			System.out.println("insert 성공");
		} else {
			System.out.println("insert 실패");
		}
		
		// update test
		empl.setDept("관리");
		check = empDb.employeeUpdate(empl);

		if (check) {
			System.out.println("update 성공");
		} else {
			System.out.println("update 실패");
		}

		
		// delete 
		check = empDb.employeeDelete("111111");
		if (check) {
			System.out.println("delete 성공");
		} else {
			System.out.println("delete 실패");
		}

		
		// select 
		list = empDb.employeeSearch("홍길동", 1);
		
		for (int i=0; i<list.size(); i++) {
			empl = (Employee) list.get(i);
			System.out.println(empl.getName() + " : " + empl.getSocialno());
		}
	}
}
```

<br>
<br><br>

# 트리와 그래프
---

## 트리(Tree)
원소들간의 1:n 관계를 가지는 비선형 자료구조<br>
각각의 원소를 선으로 연결하여 부모-자식 관계를 표현한 계층형 자료구조<br>
<br><br>
💡**용어**
* **노드 :** 트리의 원소
* **간선 :** 노드를 연결하는 선
* **차수(degree)**
  * 노드의 차수 : 노드에 연결된 자식의 수(손자 포함X)
  * 트리의 차수 : 트리에 있는 노드의 차수 중 가장 높은 차수
* **높이**
  * 노드의 높이 : 루트에서 노드에 이르는 간선의 수(노드의 레벨)
  * 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값(최대 레벨)
* **루트노드** : 시작, 맨 위에 위치하는 노드
* **단말노드** : 자식이 없는 노드, 차수가 0인 노드(leaf node)
* 형제노드 : 부모가 같은 노드
* **서브트리** : 자식노드로부터 뻗어나간 트리
  * 각 노드는 자식의 수만큼 서브트리를 가짐
* 포리스트 : 서브트리의 집합(루트노트 제외)

<center><img src="https://user-images.githubusercontent.com/57750308/146636747-67291246-27f9-4665-a32e-f37ed53ffddc.png"></center>

<br>
<br>
### 이진트리
---
자식이 최대 둘인 트리(왼쪽 자식노드, 오른쪽 자식 노드), 0 <= 노드의 차수 <= 2<br>
이진트리의 서브트리는 모두 이진트리<br>

<center><img src="https://user-images.githubusercontent.com/57750308/146636839-5fbabd20-415c-45a0-b9f7-15504b44cb23.png"></center>

<br><br>

* 포화이진트리
  * 모든 레벨의 노드가 포화상태
  * 높이가 h일 때, 최대 노트 개수인 2^(h+1) - 1 개의 노드를 가짐
  * 루트를 1번으로하여 위->아래, 좌->우 순으로 순차 번호를 가짐

<center><img src="https://user-images.githubusercontent.com/57750308/146636901-fc347dd4-cc32-472b-8ce2-c6cd00fa4fb9.png"></center>

* 완전이진트리
  * 포화이진트리에서 leaf들을 오른쪽에서부터 제거하여 얻어진 트리
    * 1~N번까지 빈자리가 없음
  * 높이가 h이고 노드 수가 n개일 때 h+1 <= n < 2^h+1 - 1 개의 노드를 가짐

<center><img src="https://user-images.githubusercontent.com/57750308/146636993-d75b22f8-ed0f-45ea-8e9f-5e361e61d6d1.png"></center>

* 편향이진트리
  * 높이 h에 대해 최소 개수의 노드를 가지면서 한 방향의 자식노드만 가짐
  * 왼쪽편향이진트리(모든 노드가 왼쪽 자식노드만을 가짐)
  * 오른쪽편향이진트리(모든 노드가 오른쪽 자식노드만을 가짐

<center><img src="https://user-images.githubusercontent.com/57750308/146637031-4fd30a48-8381-47a3-8cbf-387e083a5b0c.png"></center>

<br><br>

### 이진탐색트리
---
이진트리에 탐색을 위한 조건을 추가하여 정의한 자료구조<br>

* 모든 노드는 서로 다른 유일키를 가짐
* 부모 노드보다 키가 작은 노드는 왼쪽, 큰 노드는 오른쪽에 위치
* 서브트리도 이진탐색 트리

<br>
* 탐색 연산
  * 노드의 키 값과 찾는 키 값 비교하여 좌/우로 이동하며 탐색

<center><img src="https://user-images.githubusercontent.com/57750308/146637147-346eb2e8-1e3c-4016-bd2c-a6b359efe404.png"></center>

* 삽입 연산
  * 탐색 연산 수행하여 탐색 실패가 결정되는 위치에 삽입
  * 같은 원소가 트리에 있다면 삽입 X

<center><img src="https://user-images.githubusercontent.com/57750308/146637179-10e06a00-3b91-42f4-bf19-6e34ef4a1e33.png"></center>

* 삭제 연산
  * 탐색 연산 수행하여 찾은 뒤 삭제, 그 후 이진트리 재구성 작업
    * 단말 노드인 경우 : 삭제
    * 자식노드가 있는 경우 : 삭제 후 자식노드 위치 조정

<center><img src="https://user-images.githubusercontent.com/57750308/146637196-d42e3434-63ec-4dd6-b74e-7d2655b1a00f.png"></center>


<br><br>

## 그래프(Graph)
n:n의 관계를 가지는 원소들을 표현하기 위한 자료구조<br>
정점(vertex, node)들과 간선(edge)들의 집합으로 구성<br>
`G = (V, E)`<br>
<br>

* 무방향 그래프(Undirected Graph)
  * 두 정점 Vi와 Vj를 연결하는 간선(Vi, Vj)에 방향이 없음
  * (Vi, Vj)와 (Vj, Vi)는 같은 간선

<center><img src="https://user-images.githubusercontent.com/57750308/146637266-f9082ed0-fc21-4568-b371-0a06e651b94d.png"></center>

* 방향 그래프(Directed Graph)
  * 간선이 방향을 가지고 있는 그래프
  * <Vi, Vj>에서 Vi는 꼬리(tail), Vj는 머리(head)
  * <Vi, Vj>와 <Vj, Vi>는 서로 다른 간선

<center><img src="https://user-images.githubusercontent.com/57750308/146637341-f0e87992-8335-4aac-bc23-05e11fa477b0.png"></center>

* 완전 그래프
  * 모든 정점이 간선으로 연결되어 최대 간선 수를 가진 그래프
  * 정점이 n개인 무방향 그래프에서 최대 간선 수
    * n(n-1) / 2 개
  * 정점이 n개인 방향 그래프에서 최대 간선 수
    * n(n-1) 개

<center><img src="https://user-images.githubusercontent.com/57750308/146637400-6838770c-bbc1-4292-82ff-890ced333648.png"></center>

* 부분 그래프
  * 원래 그래프에서 일부 정점이나 간선을 제외하여 만든 그래프

<center><img src="https://user-images.githubusercontent.com/57750308/146637436-426345a1-9e84-4ee3-8add-a6d48b69214c.png"></center>

* 가중 그래프, 네트워크
  * 정점을 연결하는 간선에 가중치(weight, cost)를 할당한 그래프

<center><img src="https://user-images.githubusercontent.com/57750308/146637459-fc97305f-c364-4c3d-a6b2-ff17582ee851.png"></center>


<br><br>
💡**용어**<br>
* **인접 :** 두 정점을 연결하는 간선이 있을 때
* **부속 :** 간선을 정점에 부속되어 있다고 함
* **차수(degree) :** 정점에 부속되어 있는 간선의 수
  * 진입차수 : 정점을 머리로 하는 간선의 수
  * 진출차수 : 정점을 꼬리로 하는 간선의 수
* **경로(path) :** 간선을 따라 갈 수 있는 길을 나열한 리스트
* 경로길이 : 경로를 구성하는 간선의 수
* 단순경로 : 모두 다른 정점으로 구성된 경로
* 사이클 : 단순경로 중 경로의 시작 정점과 마지막 정점이 같은 경로
* DAG(Directecd Acyclic Graph) : 방향 그래프이면서 사이클이 없는 그래프
* **연결 그래프**
  * 서로 다른 모든 쌍의 정점들 사이에 경로가 있는 그래프
  * 떨어져있는 정점이 없는 그래프

<br><br>

### 그래프의 구현
---
**인접 행렬 :** 그래프의 두 정점을 연결한 간선의 유무를 2차원 행렬로 저장
1. n개의 정점을 가진 그래프 -> n x n 정방행렬
2. 행렬의 행번호(진출)와 열번호(진입)는 그래프의 정점
3. 행렬 값 : 두 정점이 인접하면 1, 아니면 0
4. 항상 n x n 개의 메모리 사용
- 정점에 비해 간선의 개수가 적은 경우 메모리 낭비 발생

<center><img src="https://user-images.githubusercontent.com/57750308/146637750-21055104-f070-4401-9500-7f83b22b122d.png"></center>

<br><br>

**인접 리스트 :** 각 정점에 대한 인접 정점들을 연결하여 만든 단순 연결 리스트
1. 각 정점의 차수만큼 노드를 연결(오름차순으로 연결)
2. 각 노드는 정점을 저장하는 필드와 다음 인접 정점을 연결하는 링크 필드로 구성
3. 헤드 노드는 정점에 대한 리스트의 시작을 표현

<center><img src="https://user-images.githubusercontent.com/57750308/146637873-7f05bb70-b0db-47d5-836f-1c42922bb670.png"></center>

<br><br>

### 그래프 탐색(Graph Search)
---
하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한 번씩 방문하여 처리하는 연산<br>
그래프 순회(Graph Traversal)라고도 함<br>
<br>
* **깊이 우선 탐색(DFS : Depth First Search)**
  * 한 지점을 골라 탐색하다가 아무리 탐색해도 나오지 않으면 다른 지점으로 옮김
* **너비 우선 탐색(BFS : Breadth First Search)**
  * 여러 지점을 고르게 탐색해보고 나오지 않으면 다시 좀 더 깊게 탐색

<br><br>

## Java에서의 Tree
java.util 패키지의 TreeSet, TreeMap 이진트리 사용
<br><br>

### TreeSet`<E>`
---
- **first()** : 가장 작은 값
- **last()** : 가장 큰 값
- **lower(E e) :** e보다 작은 값
- **higher(E e) :** e보다 큰 값
- **floor(E e) :** e보다 같거나 바로 아래 값
- **ceiling(E e) :** e보다 같거나 바로 위 값
- **pollFirst() :** set은 저장할 때 순서가 없으나 treeSet에서의 오름차순으로 정렬된 순서로 값을 가져올 수 있는 메소드
- **descendingSet() :** 내림차순 정렬으로 정렬된 NavigableSet<E> 반환
  * 한 번 더 하면 오름차순 정렬됨
- **subSet(E start, boolean, E end, boolean) :** start~end 사이의 값을 NavigableSet<E>으로 반환
  * boolean은 start, end 포함 여부
  * `ex) subSet(c, true, f, true) : c <= n <= f로 ca~~f까지(fa는 X)`

```java
import java.util.TreeSet;

public class TreeSetExample1 {
	public static void main(String[] args) {
		TreeSet<Integer> scores = new TreeSet<Integer>();
		scores.add(new Integer(87));
		scores.add(new Integer(98));
		scores.add(new Integer(75));
		scores.add(new Integer(95));
		scores.add(new Integer(80));
		
		Integer score = null;
		
		score = scores.first();
		System.out.println("가장 낮은 점수: " + score);	// 75
		
		score = scores.last();
		System.out.println("가장 높은 점수: " + score + "\n");	// 98
		
		score = scores.lower(new Integer(95));
		System.out.println("95점 아래 점수: " + score);	// 87
		
		score = scores.higher(new Integer(95));
		System.out.println("95점 위 점수: " + score + "\n");	// 98
		
		score = scores.floor(new Integer(95));
		System.out.println("95이거나 바로 아래 점수: " + score);	// 95
		
		score = scores.ceiling(new Integer(85));
		System.out.println("85점 이거나 바로 위 점수: " + score + "\n");	// 87
		
		NavigableSet<Integer> descendingSet = scores.descendingSet();
		for(Integer score2 : descendingSet) {
			System.out.print(score2 + " ");	// 98 95 87 80 75
		}
		System.out.println();
		
		NavigableSet<Integer> ascendingSet = descendingSet.descendingSet();
		
		for(Integer score2 : ascendingSet) {
			System.out.print(score2 + " ");	// 75 80 87 95 98 
		}
		System.out.println();
			
		while(!scores.isEmpty()) {
			score = scores.pollFirst();
			System.out.println(score + "(남은 객체 수: " + scores.size() + ")");	// 75 80 87 95 98 
		}
	}
}
```
```java
import java.util.NavigableSet;
import java.util.TreeSet;

public class TreeSetExample3 {
	public static void main(String[] args) {
		TreeSet<String> treeSet = new TreeSet<String>();
		treeSet.add("apple");
		treeSet.add("forever");		
		treeSet.add("description");
		treeSet.add("ever");
		treeSet.add("zoo");
		treeSet.add("base");
		treeSet.add("guess");
		treeSet.add("cherry");
		
		System.out.println("[c~f 사이의 단어 검색]");
		NavigableSet<String> rangeSet = treeSet.subSet("c", true, "f", true);
		for(String word : rangeSet) {
			System.out.println(word);	// cherry, description, ever
		}
	}
}
```

<br><br>

### TreeMap<K k, V v>
---
- **firstEntry() :** 키가 가장 작은 값
- **lastEntry() :** 키가 가장 큰 값
- **lowerEntry(E e) :** 키가 e보다 작은 값
- **higherEntry(E e) :** 키가 e보다 큰 값
- **floorEntry(E e) :** 키가 e보다 같거나 작은 값
- **ceilingEntry(E e) :** 키가 e보다 같거나 큰 값
- **pollFirstEntry() :** 저장된 원소 중 키 값이 가장 작은 entry를 반환
- **descendingMap() :** 내림차순으로 정렬된 NavigableMap<K k, V v> 반환
  * 한 번 더 하면 오름차순 정렬됨
- **subMap(E start, boolean, E end, boolean) :** start~end 사이의 값을 NavigableMap<K k, V v>로 반환
  * boolean은 start, end 포함 여부

```java
import java.util.Map;
import java.util.NavigableMap;
import java.util.Set;
import java.util.TreeMap;

public class TreeMapExample1 {
	public static void main(String[] args) {
		TreeMap<Integer,String> scores = new TreeMap<Integer,String>();
		scores.put(new Integer(87), "홍길동");
		scores.put(new Integer(98), "이동수");
		scores.put(new Integer(75), "박길순");
		scores.put(new Integer(95), "신용권");
		scores.put(new Integer(80), "김자바");
		
		Map.Entry<Integer, String> entry = null;
		
		entry = scores.firstEntry();
		// 75-박길순
		System.out.println("가장 낮은 점수: " + entry.getKey() + "-" + entry.getValue());
		
		entry = scores.lastEntry();
		// 98-이동수
		System.out.println("가장 높은 점수: " + entry.getKey() + "-" + entry.getValue() + "\n");
		
		entry = scores.lowerEntry(new Integer(95));
		// 87-홍길동
		System.out.println("95점 아래 점수: " + entry.getKey() + "-" + entry.getValue());
		
		entry = scores.higherEntry(new Integer(95));
		// 98-이동수
		System.out.println("95점 위 점수: " + entry.getKey() + "-" + entry.getValue() + "\n");
		
		entry = scores.floorEntry(new Integer(95));
		// 95-신용권
		System.out.println("95이거나 바로 아래 점수: " + entry.getKey() + "-" + entry.getValue());
		
		entry = scores.ceilingEntry(new Integer(85));
		// 87-홍길동
		System.out.println("85점 이거나 바로 위 점수: " + entry.getKey() + "-" + entry.getValue() + "\n");

		NavigableMap<Integer,String> descendingMap = scores.descendingMap();
		Set<Map.Entry<Integer,String>> descendingEntrySet = descendingMap.entrySet();
		for(Map.Entry<Integer,String> entry2 : descendingEntrySet) {
			// 98-이동수 95-신용권 87-홍길동 80-김자바 75-박길순 
			System.out.print(entry2.getKey() + "-" + entry2.getValue() + " ");
		}
		System.out.println();
		
		NavigableMap<Integer,String> ascendingMap = descendingMap.descendingMap();
		Set<Map.Entry<Integer,String>> ascendingEntrySet = ascendingMap.entrySet();
		for(Map.Entry<Integer, String> entry2 : ascendingEntrySet) {
			// 75-박길순 80-김자바 87-홍길동 95-신용권 98-이동수
			System.out.print(entry2.getKey() + "-" + entry2.getValue() + " ");
		}
		System.out.println();
		
		while(!scores.isEmpty()) {
			entry = scores.pollFirstEntry();
			// 75-박길순 80-김자바 87-홍길동 95-신용권 98-이동수
			System.out.println(entry.getKey() + "-" + entry.getValue() + "(남은 객체 수: " + scores.size() + ")");
		}
	}
}
```
```java
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;

public class TreeMapExample3 {
	public static void main(String[] args) {
		TreeMap<String,Integer> treeMap = new TreeMap<String,Integer>();
		treeMap.put("apple", new Integer(10));
		treeMap.put("forever", new Integer(60));		
		treeMap.put("description", new Integer(40));
		treeMap.put("ever", new Integer(50));
		treeMap.put("zoo", new Integer(10));
		treeMap.put("base", new Integer(20));
		treeMap.put("guess", new Integer(70));
		treeMap.put("cherry", new Integer(30));
		
		System.out.println("[c~f 사이의 단어 검색]");
		NavigableMap<String,Integer> rangeMap = treeMap.subMap("c", true, "f", true);
		for(Map.Entry<String, Integer> entry : rangeMap.entrySet()) {
			// cherry-30페이지, description-40페이지, ever-50페이지
			System.out.println(entry.getKey() + "-" + entry.getValue() + "페이지");
		}
	}
}
```

<br><br>

### Comparable과 Comparator
---
TreeSet과 TreeMap은 정렬을 위해 Comparable을 구현한 객체를 요구<br>
<br>
숫자 타입일 경우 값으로 정렬, 문자 타입일 경우 유니코드로 정렬<br>
=> 사용자 정의 클래스에서는 Comparable interface를 구현하여 compareTo() 메소드를 오버라이딩해야함<br>

* **compareTo()** : return 값이 양수면 뒤로, return 값이 음수면 앞으로 위치시킴

```java
public class Person implements Comparable<Person> {
	public String name;
	public int age;
	
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	
	@Override
	public int compareTo(Person o) {
		// 오름차순 정렬
		if(age<o.age) return -1;	
		else if(age == o.age) return 0;
		else  return 1;
	}
}
```
```java
import java.util.Iterator;
import java.util.TreeSet;

public class ComparableExample {
	public static void main(String[] args) {
		TreeSet<Person> treeSet = new TreeSet<Person>();
		
		treeSet.add(new Person("홍길동", 45));
		treeSet.add(new Person("김자바", 25));
		treeSet.add(new Person("박지원", 31));
		
		Iterator<Person> iterator = treeSet.iterator();
		while(iterator.hasNext()) {
			Person person = iterator.next();
			// 김자바:25, 박지원:31, 홍길동:45
			System.out.println(person.name + ":" + person.age);
		}
	}
}
```

<br><br>
<br>
Comparable 비구현 객체를 정렬하려면 TreeSet, TreeMap 생성자의 매개값으로 **정렬자(Comparator)**를 제공<br>
<br>
**정렬자 :** Comparator 인터페이스를 구현한 객체로 compare() 메소드를 오버라이딩<br>

* **compare()** : return 값이 양수면 뒤로, return 값이 음수면 앞으로 위치시킴

```java
import java.util.Comparator;

public class DescendingComparator implements Comparator<Fruit> {
	@Override
	public int compare(Fruit o1, Fruit o2) {
		// 내림차순 정렬
		if(o1.price < o2.price) return 1;
		else if(o1.price == o2.price) return 0;
		else return -1;	
	}
}
```
```java
public class Fruit {
	public String name;
	public int price;
	
	public Fruit(String name, int price) {
		this.name = name;
		this.price = price;
	}
}
```
```java
import java.util.Iterator;
import java.util.TreeSet;

public class ComparatorExample {
	public static void main(String[] args) {
		//Fruit이 Comparable을 구현하지 않았기 때문에 예외 발생
		//TreeSet<Fruit> treeSet = new TreeSet<Fruit>();	
		
		// 내림차순으로 정렬하는 정렬자 제공
		TreeSet<Fruit> treeSet = new TreeSet<Fruit>(new DescendingComparator());
		treeSet.add(new Fruit("포도", 3000));
		treeSet.add(new Fruit("수박", 10000));		
		treeSet.add(new Fruit("딸기", 6000));
		Iterator<Fruit> iterator = treeSet.iterator();
		while(iterator.hasNext()) {
			Fruit fruit = iterator.next();
			// 수박:10000, 딸기:6000, 포도:3000
			System.out.println(fruit.name + ":" + fruit.price);
		}
	}
}
```


<br><br><br>

# 실습문제
---
**병원 업무 데이터베이스 생성 및 조회 실습**<br>
`1. 테이블 스페이스 만들기`<br>
`2. 사용자 생성(ID : hospital, password : hospital)`<br>
`3. hospital 사용자에게 권한 주기(GRANT)`<br>
`4. 테이블 생성 및 data insert`<br>
`5. 테이블 검색 실습`
```sql
--conn sys

CREATE TABLESPACE hostp_tbs
DATAFILE 'C:\oraclexe\app\oracle\oradata\XE\hospitaldb.dbf'
size 20M;

CREATE USER hospital
IDENTIFIED BY hospital
DEFAULT TABLESPACE hostp_tbs;

GRANT CONNECT, RESOURCE TO hospital;


--conn hospital
--CREATE TABLE
/*table 생성시 primary key, foreign key 등 설정할 것
Doctors 등 primary key를 위한 sequence를 create할 것*/
CREATE SEQUENCE doc_seq
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE nur_seq
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE pat_seq
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE treat_seq
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE chart_seq
INCREMENT BY 1
START WITH 1;

--시퀀스 초기화
/*DROP SEQUENCE doc_seq;
DROP SEQUENCE nur_seq;
DROP SEQUENCE pat_seq;
DROP SEQUENCE treat_seq;
DROP SEQUENCE chart_seq;*/

--의사는 의사ID를 부여하여 식별하며 담당진료과목, 성명, 성별, 전화번호, 이메일, 직급을 가짐
--환자에 대한 모든 정보 검색
CREATE TABLE Doctors (
    순서 NUMBER(4) UNIQUE NOT NULL, 
    doc_id NUMBER(10) NOT NULL,
    major_treat VARCHAR2(25) NOT NULL,
    doc_name VARCHAR2(20) NOT NULL,
    doc_gen CHAR(1) NOT NULL,
    doc_phone VARCHAR2(15) NULL,
    doc_email VARCHAR2(50) UNIQUE,
    doc_position VARCHAR2(20) NOT NULL
);

ALTER TABLE Doctors
ADD CONSTRAINT doc_id_pk PRIMARY KEY(doc_id);

--간호사ID를 부여하여 식별하며 담당업무, 성명, 성별, 전화번호, 이메일, 직급을 가짐
--병원 진료차트 정보 검색, 환자 관리
CREATE TABLE Nurses (
    순서 NUMBER(4) UNIQUE NOT NULL,
    nur_id NUMBER(10) NOT NULL,
    major_job VARCHAR2(25) NOT NULL,
    nur_name VARCHAR2(20) NOT NULL,
    nur_gen CHAR(1) NOT NULL,
    nur_phone VARCHAR2(15) NULL,
    nur_email VARCHAR2(50) UNIQUE,
    nur_position VARCHAR2(20) NOT NULL
);

ALTER TABLE Nurses
ADD CONSTRAINT nur_id_pk PRIMARY KEY(nur_id);

--환자ID를 부여하여 식별하며 담당의사, 담당간호사, 환자성명, 주민번호, 성별, 주소, 전화번호, 이메일, 직업을 가짐
--진료내용 등의 정보 검색, 담당의사 조회 가능
CREATE TABLE Patients (
    순서 NUMBER(4) UNIQUE NOT NULL,
    pat_id NUMBER(10) NOT NULL,
    nur_id NUMBER(10) NOT NULL,
    doc_id NUMBER(10) NOT NULL,
    pat_name VARCHAR2(20) NOT NULL,
    pat_gen CHAR(1) NOT NULL,
    pat_jumin VARCHAR2(14) NOT NULL,
    pat_addr VARCHAR2(100) NOT NULL,
    pat_phone VARCHAR2(15) NULL,
    pat_email VARCHAR2(50) UNIQUE,
    pat_job VARCHAR2(20) NOT NULL
);

ALTER TABLE Patients
ADD CONSTRAINT pat_id_pk PRIMARY KEY(pat_id);

ALTER TABLE Patients
ADD CONSTRAINT R_2 FOREIGN KEY(doc_id) REFERENCES Doctors(doc_id) ON DELETE CASCADE;

ALTER TABLE Patients
ADD CONSTRAINT R_3 FOREIGN KEY(nur_id) REFERENCES Nurses(nur_id)ON DELETE CASCADE;

--진료ID는 날짜+진료순번으로 부여하고 진료한 의사ID, 환자ID, 진료내용, 진료날짜를 포함한다
CREATE TABLE Treatments (
    순서 NUMBER(4) UNIQUE NOT NULL,
    treat_id NUMBER(15) NOT NULL,
    pat_id NUMBER(10) NOT NULL,
    doc_id NUMBER(10) NOT NULL,
    treat_contetns VARCHAR2(1000) NOT NULL,
    treat_date DATE NOT NULL
);

ALTER TABLE Treatments
ADD CONSTRAINT treat_pat_doc_id_pk PRIMARY KEY (treat_id, pat_id, doc_id);

ALTER TABLE Treatments
ADD CONSTRAINT R_5 FOREIGN KEY(pat_id) REFERENCES Patients(pat_id);

ALTER TABLE Treatments
ADD CONSTRAINT R_6 FOREIGN KEY(doc_id) REFERENCES Doctors(doc_id) ON DELETE CASCADE;

--차트는 차트번호를 부여하여 식별하며 담당의사ID, 간호사ID, 환자ID, 진료ID, 의사소견을 차트에 기록
CREATE TABLE Charts (
    순서 NUMBER(4) UNIQUE NOT NULL,
    chart_id VARCHAR2(20) NOT NULL,
    treat_id NUMBER(15) NOT NULL,
    doc_id NUMBER(10) NOT NULL,
    pat_id NUMBER(10) NOT NULL,
    nur_id NUMBER(10) NOT NULL,
    chart_contents VARCHAR2(1000) NOT NULL
);

ALTER TABLE Charts
ADD CONSTRAINT chart_treat_doc_pat_id_pk PRIMARY KEY (chart_id, treat_id, doc_id, pat_id);

ALTER TABLE Charts
ADD CONSTRAINT R_4 FOREIGN KEY(nur_id) REFERENCES Nurses(nur_id);

ALTER TABLE Charts
ADD CONSTRAINT R_7 FOREIGN KEY(treat_id, pat_id, doc_id) REFERENCES Treatments(treat_id, pat_id, doc_id) ON DELETE CASCADE;

/*============================================================================================*/
--INSERT
--Doctors
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 980312, '소아과', '이태정', 'M', '010-333-1340', 'ltj@hanbh.com', '과장');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 000601, '내과', '안성기', 'M', '011-222-0987', 'ask@hanbh.com', '과장');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 001208, '외과', '김민종', 'M', '010-333-8743', 'kmj@hanbh.com', '과장');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 020403, '피부과', '이태서', 'M', '019-777-3764', 'lts@hanbh.com', '과장');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 050900, '소아과', '김연아', 'F', '010-555-3746', 'kya@hanbh.com', '전문의');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 050101, '내과', '차태현', 'M', '011-222-7643', 'cth@hanbh.com', '전문의');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 062019, '소아과', '전지현', 'F', '010-999-1265', 'jjh@hanbh.com', '전문의');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 070576, '피부과', '홍길동', 'M', '016-333-7263', 'hgd@hanbh.com', '전문의');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 080543, '방사과', '유재석', 'M', '010-222-1263', 'yjs@hanbh.com', '과장');
INSERT INTO Doctors VALUES (doc_seq.NEXTVAL, 091001, '외과', '김병만', 'M', '010-555-3542', 'kbm@hanbh.com', '전문의');

--Nurses
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 050302, '소아과', '김은영', 'F', '010-555-8751', 'key@hanbh.com', '수간호사');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 050021, '내과', '윤성애', 'F', '016-333-8745', 'ysa@hanbh.com', '수간호사');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 040089, '피부과', '신지원', 'M', '010-666-7646', 'sjw@hanbh.com', '주임');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 070605, '방사선과', '유정화', 'F', '010-333-4588', 'yjh@hanbh.com', '주임');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 070804, '내과', '라하나', 'F', '010-222-1340', 'nhn@hanbh.com', '주임');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 071018, '소아과', '김화경', 'F', '019-888-4116', 'khk@hanbh.com', '주임');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 100356, '소아과', '이선용', 'M', '010-777-1234', 'lsy@hanbh.com', '간호사');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 104145, '외과', '김현', 'M', '010-999-8520', 'kh@hanbh.com', '간호사');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 120309, '피부과', '박성완', 'M', '010-777-4996', 'psw@hanbh.com', '간호사');
INSERT INTO Nurses VALUES (nur_seq.NEXTVAL, 130211, '외과', '이서연', 'F', '010-222-3214', 'lsy2@hanbh.com', '간호사');

--Patients
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 2345, 050302, 980312, '안상건', 'M', '232345', '서울', '010-555-7845', 'ask@ab.com', '회사원');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 3545, 040089, 020403, '김성룡', 'M', '543545', '서울', '010-333-7812', 'ksr@bb.com', '자영업');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 3424, 070605, 080543, '이종진', 'M', '433424', '부산', '019-888-4859', 'ljj@ab.com', '회사원');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 7675, 100356, 050900, '최광석', 'M', '677675', '당진', '010-222-4847', 'cks@cc.com', '회사원');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 4533, 070804, 000601, '정한경', 'M', '744533', '강릉', '010-777-9630', 'jhk@ab.com', '교수');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 5546, 120309, 070576, '유원현', 'M', '765546', '대구', '016-777-0214', 'ywh@cc.com', '자영업');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 4543, 070804, 050101, '최재정', 'M', '454543', '부산', '010-555-4187', 'cjj@bb.com', '회사원');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 9768, 130211, 091001, '이진희', 'F', '119768', '서울', '010-888-3675', 'ljh@ab.com', '교수');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 4234, 130211, 091001, '오나미', 'F', '234234', '속초', '010-999-6541', 'onm@cc.com', '학생');
INSERT INTO Patients VALUES (pat_seq.NEXTVAL, 7643, 071018, 062019, '송성묵', 'M', '987643', '서울', '010-222-5874', 'ssm@bb.com', '학생');

--Treatments
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 130516023, 2345, 980312, '감기, 몸살', '2013-05-16');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 130628100, 3545, 020403, '피부 트러블 치료', '2013-06-28');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 131205056, 3424, 080543, '목 디스크로 MRI 촬영', '2013-12-05');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 131218024, 7675, 050900, '중이염', '2013-12-18');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 131224012, 4533, 000601, '장염', '2013-12-24');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 140103001, 5546, 070576, '여드름 치료', '2014-01-03');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 140109026, 4543, 050101, '위염', '2014-01-09');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 140226102, 9768, 091001, '화상치료', '2014-02-26');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 140303003, 4234, 091001, '교통사고 외상치료', '2014-03-03');
INSERT INTO Treatments VALUES (treat_seq.NEXTVAL, 140308087, 7643, 062019, '장염', '2014-03-08');

--Charts
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'p_130516023', 130516023, 980312, 2345, 050302, '감기 주사 및 약 처방');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'd_130628100', 130628100, 020403, 3545, 040089, '피부 감염 방지 주사');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'r_131205056', 131205056, 080543, 3424, 070605, '주사 처방');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'p_131218024', 131218024, 050900, 7675, 100356, '귓속청소 및 약 처방');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'i_131224012', 131224012, 000601, 4533, 070804, '장염 입원치료');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'd_140103001', 140103001, 070576, 5546, 120309, '여드름 치료약 처방');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'i_140109026', 140109026, 050101, 4543, 070804, '위내시경');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 's_140226102', 140226102, 091001, 9768, 130211, '화상 크림약 처방');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 's_140303003', 140303003, 091001, 4234, 130211, '입원치료');
INSERT INTO Charts VALUES (chart_seq.NEXTVAL, 'p_140308087', 140308087, 062019, 7643, 071018, '장염 입원치료');

COMMIT;
/*============================================================================================*/
--UPDATE, DELETE
/*홍길동 의사가 맡고 있던 담당진료과목이 피부과에서 소아과로 변경되어 내일부터 진료를 시작할 예정이다.
이 정보에 대한 테이블 정보를 변경하시오.*/
UPDATE Doctors
SET major_treat = '소아과'
WHERE doc_name = '홍길동';

/*김은영 간호사는 대학원 진학으로 오늘까지만 근무하고 퇴사하게 되었다. 이 정보에 대한 테이블 정보를 변경하시오.*/
--외래키때문에 일단 보류
DELETE FROM Nurses
WHERE nur_name = '김은영';

/*담당 진료과목이 '소아과'인 의사에 대한 정보를 출력하시오.*/
SELECT * 
FROM Doctors
WHERE major_treat = '소아과';

/*홍길동 의사에게 진료를 받은 환자에 대한 모든 정보를 출력하시오.*/
SELECT p.*, d.doc_name
FROM Patients p, Doctors d
WHERE p.doc_id = d.doc_id
AND d.doc_name = '홍길동';

/*진료날짜가 2013년 12월인 환자에 대한 모든 정보를 오름차순 정렬하여 출력하시오.*/
SELECT p.*, t.treat_date
FROM Patients p, Treatments t
WHERE p.pat_id = t.pat_id
AND t.treat_date BETWEEN '2013-12-01' AND '2013-12-31'
ORDER BY t.treat_date ASC;

/*간호사ID가 05로 시작하는 모든 간호사 정보를 출력하시오.*/
SELECT *
FROM Nurses
WHERE nur_id LIKE 05 || '%';

COMMIT;
```
<br>
**Oracle 연동 Java Programming 실습**<br>
`1. Doctors, Nurses 클래스 생성`<br>
`2. Main method가 있는 class를 별도 코딩`<br>
`(1. 전체조회, 2. 의사 추가, 3. 의사 정보 수정, 4. 의사 삭제, 5. 종료)`
```java
public class Doctors {
	private int doc_seq;
	private int doc_id;
	private String major_treat;
	private String doc_name;
	private char doc_gen;
	private String doc_phone;
	private String doc_email;
	private String doc_position;
	
	public Doctors(int doc_seq) {
		this.doc_seq = doc_seq;
	}

	public int getDoc_seq() {
		return doc_seq;
	}

	public void setDoc_seq(int doc_seq) {
		this.doc_seq = doc_seq;
	}

	public int getDoc_id() {
		return doc_id;
	}

	public void setDoc_id(int doc_id) {
		this.doc_id = doc_id;
	}

	public String getMajor_treat() {
		return major_treat;
	}

	public void setMajor_treat(String major_treat) {
		this.major_treat = major_treat;
	}

	public String getDoc_name() {
		return doc_name;
	}

	public void setDoc_name(String doc_name) {
		this.doc_name = doc_name;
	}

	public char getDoc_gen() {
		return doc_gen;
	}

	public void setDoc_gen(char doc_gen) {
		this.doc_gen = doc_gen;
	}

	public String getDoc_phone() {
		return doc_phone;
	}

	public void setDoc_phone(String doc_phone) {
		this.doc_phone = doc_phone;
	}

	public String getDoc_email() {
		return doc_email;
	}

	public void setDoc_email(String doc_email) {
		this.doc_email = doc_email;
	}

	public String getDoc_position() {
		return doc_position;
	}

	public void setDoc_position(String doc_position) {
		this.doc_position = doc_position;
	}	
}
```
```java
public class Nurses {
	private int nur_seq;
	private int nur_id;
	private String major_job;
	private String nur_name;
	private String nur_gen;
	private String nur_phone;
	private String nur_email;
	private String nur_position;
	
	public Nurses(int nur_seq) {
		this.nur_seq = nur_seq;
	}

	public int getNur_seq() {
		return nur_seq;
	}

	public void setNur_seq(int nur_seq) {
		this.nur_seq = nur_seq;
	}

	public int getNur_id() {
		return nur_id;
	}

	public void setNur_id(int nur_id) {
		this.nur_id = nur_id;
	}

	public String getMajor_job() {
		return major_job;
	}

	public void setMajor_job(String major_job) {
		this.major_job = major_job;
	}

	public String getNur_name() {
		return nur_name;
	}

	public void setNur_name(String nur_name) {
		this.nur_name = nur_name;
	}

	public String getNur_gen() {
		return nur_gen;
	}

	public void setNur_gen(String nur_gen) {
		this.nur_gen = nur_gen;
	}

	public String getNur_phone() {
		return nur_phone;
	}

	public void setNur_phone(String nur_phone) {
		this.nur_phone = nur_phone;
	}

	public String getNur_email() {
		return nur_email;
	}

	public void setNur_email(String nur_email) {
		this.nur_email = nur_email;
	}

	public String getNur_position() {
		return nur_position;
	}

	public void setNur_position(String nur_position) {
		this.nur_position = nur_position;
	}	
}
```
```java
import java.util.*;
import java.sql.*;

public class HospitalDB {
	Connection conn;
	
	public HospitalDB() {
		String url = "jdbc:oracle:thin:@localhost:1521:xe";
		String userid = "hospital";
		String pwd = "hospital";
		
		try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
			System.out.println("driver is loaded successfully");
		} catch (ClassNotFoundException e) {
			System.out.println("driver is load failure!");
		}
		

		try {
			conn = DriverManager.getConnection(url, userid, pwd);
			System.out.println("database connection is success");
		} catch (SQLException e) {
			System.out.println("database connection failure");
		}
	}
	
	public void selectAll () {
		try {
			String query = "SELECT * FROM Doctors";

			PreparedStatement pstmt = conn.prepareStatement(query);
			ResultSet rs = pstmt.executeQuery();
						
			System.out.println("\n<Doctors table>");
			System.out.println("-----------------------------------------------------------------------------");
			System.out.println("순서|doc_id|major_treat|doc_name|doc_gen|doc_phone|doc_email|doc_position");
			System.out.println("-----------------------------------------------------------------------------");
			
			while (rs.next()) {
				System.out.print(rs.getInt(1) + " | ");
				System.out.print(rs.getInt(2) + " | ");
				System.out.print(rs.getString(3) + " | ");
				System.out.print(rs.getString(4) + " | ");
				System.out.print(rs.getString(5) + " | ");
				System.out.print(rs.getString(6) + " | ");
				System.out.print(rs.getString(7) + " | ");
				System.out.print(rs.getString(8) + " | ");
				System.out.println();
			}

			query = "SELECT * FROM Nurses";
			
			pstmt = conn.prepareStatement(query);
			rs = pstmt.executeQuery();
			
			System.out.println("\n<Nurses table>");
			System.out.println("-----------------------------------------------------------------------------");
			System.out.println("순서|nur_id|major_job|nur_name|nur_gen|nur_phone|nur_email|nur_position");
			System.out.println("-----------------------------------------------------------------------------");
			
			while (rs.next()) {
				System.out.print(rs.getInt(1) + " | ");
				System.out.print(rs.getInt(2) + " | ");
				System.out.print(rs.getString(3) + " | ");
				System.out.print(rs.getString(4) + " | ");
				System.out.print(rs.getString(5) + " | ");
				System.out.print(rs.getString(6) + " | ");
				System.out.print(rs.getString(7) + " | ");
				System.out.print(rs.getString(8) + " | ");
				System.out.println();
			}	
			rs.close();
			pstmt.close();
		} catch (SQLException e) {
//			e.printStackTrace();
			System.out.println("select all error");
		}
	}
	
	public int getNextval(String tableName) {
		String seqName = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		
		if(tableName.toUpperCase().equals("DOCTORS")) {
			seqName = "doc_seq";
		}else if(tableName.toUpperCase().equals("NURSES")) {
			seqName = "nur_seq";
		}

		String query = "SELECT " + seqName + ".NEXTVAL FROM dual";
		
		try {		 
			pstmt = conn.prepareStatement(query);
			
			rs = pstmt.executeQuery();
			if(rs.next()) {
				return rs.getInt(1);
			}
		} catch (SQLException e) {
			//e.printStackTrace();
			System.out.println("get nextval error");
		} finally {
			try {
				rs.close();
				pstmt.close();
			} catch (SQLException e) {
				System.out.println("resource close error");
				e.printStackTrace();
			}
		}		
		return -1;
	}
	
	public boolean insertDoctors(Doctors doctors) {
		String query = "INSERT INTO Doctors VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
		PreparedStatement pstmt = null;
		
		try {
			pstmt = conn.prepareStatement(query);
			pstmt.setInt(1, doctors.getDoc_seq());
			pstmt.setInt(2, doctors.getDoc_id());
			pstmt.setString(3, doctors.getMajor_treat());
			pstmt.setString(4, doctors.getDoc_name());
			pstmt.setString(5, Character.toString(doctors.getDoc_gen()));
			pstmt.setString(6, doctors.getDoc_phone());
			pstmt.setString(7, doctors.getDoc_email());
			pstmt.setString(8, doctors.getDoc_position());
			
			int result = pstmt.executeUpdate();
			pstmt.close();
			
			if(result != 0) {
				return true;
			}
			
		} catch (SQLException e) {
			//e.printStackTrace();
			System.out.println("insert doctors error");
		}
		return false;
	}
	
	public boolean update(String tableName, String searchCol, String searchVal, String updateCol, String updateVal) {
		String query = "UPDATE " + tableName + " SET " + updateCol + 
				 " = ? WHERE " + searchCol;
		PreparedStatement pstmt = null;
		
		query += checkSearchVal(searchVal);

		try {
			pstmt = conn.prepareStatement(query);
			
			pstmt.setString(1, updateVal);
			
			int result = pstmt.executeUpdate();
			pstmt.close();
			
			if(result != 0) {
				return true;
			}			
		} catch (SQLException e) {
			//e.printStackTrace();
			System.out.println("update error");
		}
		return false;
	}

	public boolean delete(String tableName, String searchCol, String searchVal) {
		String query = "DELETE FROM " + tableName + " WHERE " + searchCol;
		PreparedStatement pstmt = null;
		
		query += checkSearchVal(searchVal);
		
		try {
			pstmt = conn.prepareStatement(query);
			
			int result = pstmt.executeUpdate();
			pstmt.close();
			
			if(result != 0) {
				return true;
			}
		} catch (SQLException e) {
			//e.printStackTrace();
			System.out.println("delete error");
		}
		return false;
	}
	
	public String checkSearchVal(String searchVal) {
		if(searchVal.toUpperCase().indexOf("NOT NULL") != -1)
			searchVal = " IS NOT " + null;
		else if(searchVal.toUpperCase().indexOf("NULL") != -1)
			searchVal = " IS " + null;
		else
			searchVal = " = '" + searchVal + "'";
		
		return searchVal;
	}
	
	public ArrayList<Doctors> searchDoctors(String searchCol, String searchVal) {
		String query = "SELECT * FROM Doctors WHERE " + searchCol;
		PreparedStatement pstmt = null;
		
		query += checkSearchVal(searchVal);

		ArrayList<Doctors> docList = new ArrayList<>();
		ResultSet rs = null;
		try {
			pstmt = conn.prepareStatement(query);
			
			rs = pstmt.executeQuery();
			
			while(rs.next()) {
				Doctors doctors = new Doctors(rs.getInt(1));
				doctors.setDoc_id(rs.getInt(2));
				doctors.setMajor_treat(rs.getString(3));
				doctors.setDoc_name(rs.getString(4));
				doctors.setDoc_gen(rs.getString(5).charAt(0));
				doctors.setDoc_phone(rs.getString(6));
				doctors.setDoc_email(rs.getString(7));
				doctors.setDoc_position(rs.getString(8));
				docList.add(doctors);
			}			
			return docList;			
		} catch (SQLException e) {
			//e.printStackTrace();
			System.out.println("search doctors error");
		} finally {
			try {
				rs.close();
				pstmt.close();
			} catch (SQLException e) {
				System.out.println("resource close error");
				e.printStackTrace();
			}			
		}
		return docList;
	}
}
```
```java
import java.util.*;

public class HospitalEx {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		HospitalDB hospital = new HospitalDB();
		while(true) {
			System.out.println("========================================================");
			System.out.println("1.전체 조회 | 2.의사 추가 | 3.의사 정보 수정 | 4.의사 삭제 | 5.종료");
			System.out.println("========================================================");
			
			System.out.print("메뉴 선택 > ");
			int menu = input.nextInt();
			input.nextLine();
			
			switch(menu) {
				case 1:
					System.out.println("===전체 Table 조회===");
					hospital.selectAll();
					break;
					
				case 2:
					System.out.println("===Doctors table insert===");
					int nextVal = hospital.getNextval("doctors");
					if(nextVal != -1) {
						Doctors doctors = new Doctors(nextVal);
					
						System.out.print("doc_id : ");
						try	{
							doctors.setDoc_id(input.nextInt());
						} catch(InputMismatchException e) {
							System.out.println("doc_id must be num value");
							input.nextLine();
							continue;
						}
						input.nextLine();
						System.out.print("major_treat : ");
						doctors.setMajor_treat(input.nextLine());
						System.out.print("doc_name : ");
						doctors.setDoc_name(input.nextLine());
						System.out.print("doc_gen : ");
						char doc_gen = Character.toUpperCase(input.nextLine().charAt(0));
						if(doc_gen == 'M' || doc_gen == 'F') 
							doctors.setDoc_gen(doc_gen);
						else {
							System.out.println("doc_gen error(start with only 'M' or 'F')");
							break;
						}
						System.out.print("doc_phone(NULL 허용) : ");
						String doc_phone = input.nextLine();
						if(!doc_phone.toUpperCase().equals("NULL"))
							doctors.setDoc_phone(doc_phone);							
						else doctors.setDoc_phone(null);
						System.out.print("doc_email : ");
						doctors.setDoc_email(input.nextLine());
						System.out.print("doc_position : ");
						doctors.setDoc_position(input.nextLine());	
			
						if(hospital.insertDoctors(doctors)) {
							System.out.println("insert 성공!");
						} else System.out.println("insert 실패");
					} else System.out.println("get Nextval 실패");
					break;
					
				case 3:
					System.out.println("===Doctors table update===");
					System.out.print("찾는 조건(WHERE) 컬럼 : ");
					String searchCol = input.nextLine();
					System.out.print("찾는 조건 값 : ");
					String searchVal = input.nextLine();
					System.out.print("바꿀 컬럼(SET) : ");
					String updateCol = input.nextLine();
					System.out.print("바꿀 값(doc_phone만 NULL 허용) : ");
					String updateVal = input.nextLine();
					if(updateVal.toUpperCase().equals("NULL"))
						updateVal = null;
					
					if(hospital.update("doctors", searchCol, searchVal, updateCol, updateVal)) {
						System.out.println("update 성공!");
					} else System.out.println("update 실패");
					break;
					
				case 4:
					System.out.println("===Doctors table delete===");
					System.out.println("전부 다 지울 경우 1을 두 번 입력하세요.");
					System.out.print("지울 조건 컬럼(WHERE) : ");
					String searchCol1 = input.nextLine();
					System.out.print("지울 조건 값 : ");
					String searchVal1 = input.nextLine();
					
					if(hospital.delete("doctors", searchCol1, searchVal1)) {
						System.out.println("delete 성공!");
					} else System.out.println("delete 실패");
					break;
					
				case 5:
					System.out.println("===프로그램 종료===");
					System.exit(1);
			}
			System.out.println();
		}
	}
}
```





<br><br>


